{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Theoretical Foundation: Equations of Motion 1. Governing Equations of Motion The motion of a projectile follows the fundamental kinematic equations under uniform gravitational acceleration. Assuming no air resistance, the equations for horizontal and vertical motion are: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(g\\) is the acceleration due to gravity, - \\(t\\) is the time. 2. Time of Flight and Range The total time of flight \\(T\\) is obtained by setting \\(y(T) = 0\\) : \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range \\(R\\) is the horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 3. Family of Solutions The range depends on \\(\\sin(2\\theta)\\) , which is maximized at \\(45^\\circ\\) . Different initial velocities \\(v_0\\) and angles lead to a family of possible trajectories. Symmetry: The same range is achieved for \\(\\theta\\) and \\(90^\\circ - \\theta\\) . This provides the foundation for analyzing the range as a function of projection angle in simulations. Analysis of the Range 1. Dependence on Angle of Projection The horizontal range \\(R\\) follows the relation: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ The range is maximum at \\(45^\\circ\\) , where \\(\\sin(90^\\circ) = 1\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) produce the same range due to symmetry. 2. Influence of Other Parameters Initial Velocity ( \\(v_0\\) ): Range increases quadratically with \\(v_0\\) , meaning doubling \\(v_0\\) quadruples the range. Gravitational Acceleration ( \\(g\\) ): Higher gravity reduces range since it shortens time of flight. On the Moon (lower \\(g\\) ), projectiles travel much farther. This analysis shows how range depends on key parameters and guides real-world applications such as sports and engineering. Practical Applications 1. Uneven Terrain In real-world scenarios, projectiles often land on slopes or rough surfaces. The governing equations can be modified to account for variable ground height \\(h(x)\\) . Applications include military ballistics and sports science. 2. Air Resistance The idealized model assumes no drag, but in reality, air resistance significantly affects motion. A more realistic equation includes a drag force proportional to velocity: $$ F_d = -kv $$ where \\(k\\) is the drag coefficient. This leads to complex differential equations that require numerical solutions. Relevant in aerodynamics, meteorology, and spacecraft re-entry calculations. 3. Engineering and Astrophysics Understanding projectile motion is crucial in designing bridges, launch vehicles, and satellite trajectories. Low-gravity environments, such as Mars, influence rover landing dynamics. These adaptations help bridge theoretical models with real-world applications, making them more accurate and practical. Implementation 1. Simulation of Projectile Motion Below is a Python script to simulate projectile motion and visualize the range as a function of projection angle: import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g=9.81): angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show() # Example usage: projectile_range(v0=20) 2. Visualization The plot generated shows how the range varies with the launch angle. The maximum range occurs at \\(45^\\circ\\) . Changing initial velocity \\(v_0\\) shifts the curve but maintains the same pattern. This computational tool helps visualize how projectile range behaves under different conditions, offering insights for engineering and physics applications.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation-equations-of-motion","text":"","title":"Theoretical Foundation: Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-governing-equations-of-motion","text":"The motion of a projectile follows the fundamental kinematic equations under uniform gravitational acceleration. Assuming no air resistance, the equations for horizontal and vertical motion are: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(g\\) is the acceleration due to gravity, - \\(t\\) is the time.","title":"1. Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-time-of-flight-and-range","text":"The total time of flight \\(T\\) is obtained by setting \\(y(T) = 0\\) : \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range \\(R\\) is the horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"2. Time of Flight and Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-family-of-solutions","text":"The range depends on \\(\\sin(2\\theta)\\) , which is maximized at \\(45^\\circ\\) . Different initial velocities \\(v_0\\) and angles lead to a family of possible trajectories. Symmetry: The same range is achieved for \\(\\theta\\) and \\(90^\\circ - \\theta\\) . This provides the foundation for analyzing the range as a function of projection angle in simulations.","title":"3. Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-dependence-on-angle-of-projection","text":"The horizontal range \\(R\\) follows the relation: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ The range is maximum at \\(45^\\circ\\) , where \\(\\sin(90^\\circ) = 1\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) produce the same range due to symmetry.","title":"1. Dependence on Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-influence-of-other-parameters","text":"Initial Velocity ( \\(v_0\\) ): Range increases quadratically with \\(v_0\\) , meaning doubling \\(v_0\\) quadruples the range. Gravitational Acceleration ( \\(g\\) ): Higher gravity reduces range since it shortens time of flight. On the Moon (lower \\(g\\) ), projectiles travel much farther. This analysis shows how range depends on key parameters and guides real-world applications such as sports and engineering.","title":"2. Influence of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-uneven-terrain","text":"In real-world scenarios, projectiles often land on slopes or rough surfaces. The governing equations can be modified to account for variable ground height \\(h(x)\\) . Applications include military ballistics and sports science.","title":"1. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-air-resistance","text":"The idealized model assumes no drag, but in reality, air resistance significantly affects motion. A more realistic equation includes a drag force proportional to velocity: $$ F_d = -kv $$ where \\(k\\) is the drag coefficient. This leads to complex differential equations that require numerical solutions. Relevant in aerodynamics, meteorology, and spacecraft re-entry calculations.","title":"2. Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-engineering-and-astrophysics","text":"Understanding projectile motion is crucial in designing bridges, launch vehicles, and satellite trajectories. Low-gravity environments, such as Mars, influence rover landing dynamics. These adaptations help bridge theoretical models with real-world applications, making them more accurate and practical.","title":"3. Engineering and Astrophysics"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-simulation-of-projectile-motion","text":"Below is a Python script to simulate projectile motion and visualize the range as a function of projection angle: import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g=9.81): angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees ranges = (v0**2 * np.sin(2 * np.radians(angles))) / g plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show() # Example usage: projectile_range(v0=20)","title":"1. Simulation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-visualization","text":"The plot generated shows how the range varies with the launch angle. The maximum range occurs at \\(45^\\circ\\) . Changing initial velocity \\(v_0\\) shifts the curve but maintains the same pattern. This computational tool helps visualize how projectile range behaves under different conditions, offering insights for engineering and physics applications.","title":"2. Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Theoretical Foundation: Forced Damped Pendulum 1. Governing Equation The motion of a forced damped pendulum is described by: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(b\\) is the damping coefficient, - \\(g/L\\) represents the natural oscillation frequency, - \\(A \\cos(\\omega t)\\) is the external periodic force. 2. Small-Angle Approximation For small angles ( \\(\\theta \\approx 0\\) ), we use the approximation \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This reduces the system to a linear differential equation , which can be solved analytically. 3. Resonance and Energy Implications Natural Frequency: $$ \\omega_0 = \\sqrt{g/L} $$ Resonance Condition: When the driving frequency \\(\\omega\\) matches \\(\\omega_0\\) , the system experiences resonance , leading to large oscillations . Damping Effects: Higher damping ( \\(b\\) ) reduces oscillation amplitude and prevents unbounded energy growth. Analysis of Dynamics 1. Influence of Parameters on Motion The behavior of the forced damped pendulum depends on key parameters: Damping Coefficient ( \\(b\\) ) Higher damping reduces oscillations and eventually brings the pendulum to rest. Lower damping allows sustained motion and can lead to resonance effects. Driving Amplitude ( \\(A\\) ) Small \\(A\\) results in steady periodic motion. Large \\(A\\) can induce irregular motion, leading to chaotic behavior. Driving Frequency ( \\(\\omega\\) ) When \\(\\omega \\approx \\omega_0\\) (natural frequency), resonance occurs, amplifying oscillations. At non-resonant frequencies, motion remains stable but varies in amplitude. 2. Transition from Regular to Chaotic Motion At low driving forces , the pendulum follows predictable periodic motion. Increasing \\(A\\) or adjusting \\(\\omega\\) can introduce nonlinear effects , where motion becomes quasi-periodic or chaotic . Chaotic motion means small differences in initial conditions lead to drastically different trajectories, making long-term prediction impossible. 3. Physical Interpretation Regular motion is seen in clocks and metronomes where precise oscillations are required. Chaotic behavior appears in weather systems, electrical circuits, and biological rhythms , where nonlinearity dominates. Practical Applications of the Forced Damped Pendulum The forced damped pendulum model has widespread applications in engineering, physics, and real-world systems. Below are some key areas where it plays a crucial role: 1. Energy Harvesting Devices Example: Piezoelectric energy harvesters convert oscillations into electrical power. The pendulum\u2019s motion can be used to generate electricity in wearable sensors , self-powered devices , and vibrational energy systems . 2. Suspension Bridges Bridges experience oscillations due to wind forces and traffic loads . If the forcing frequency matches the bridge\u2019s natural frequency ( resonance ), it can cause dangerous oscillations (e.g., Tacoma Narrows Bridge collapse). Engineers use damping mechanisms to prevent excessive movement. 3. Oscillating Electrical Circuits (RLC Circuits) The forced damped pendulum is analogous to RLC circuits in electronics. In an RLC circuit: Damping ( \\(b\\) ) corresponds to electrical resistance. Natural frequency ( \\(\\omega_0\\) ) depends on inductance and capacitance. Driving force ( \\(A \\cos(\\omega t)\\) ) represents an AC voltage source. Understanding this analogy helps in designing filters, oscillators, and signal-processing devices . 4. Human Movement and Biomechanics Example: The human gait involves periodic motion controlled by muscles and external forces. Rehabilitation therapy and prosthetic limb design apply the principles of forced oscillations. Conclusion The forced damped pendulum isn\u2019t just a theoretical concept\u2014it plays a vital role in engineering, biomechanics, and energy systems . Understanding these dynamics allows us to improve stability, efficiency, and safety in various real-world applications. \ud83d\ude80 Implementation: Simulating the Forced Damped Pendulum We implement a numerical simulation of the forced damped pendulum using Python. The motion is governed by: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(b\\) is the damping coefficient, - \\(A \\cos(\\omega t)\\) is the external driving force, - \\(g/L\\) represents the natural oscillation frequency. 1. Numerical Simulation (Runge-Kutta Method) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the differential equation def pendulum(t, state, b, A, omega, g, L): theta, omega_dot = state dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.2 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency g = 9.81 # Gravity L = 1.0 # Pendulum length theta0 = 0.2 # Initial angle omega0 = 0.0 # Initial angular velocity t_span = (0, 50) # Time interval t_eval = np.linspace(*t_span, 1000) # Solve ODE using Runge-Kutta method sol = solve_ivp(pendulum, t_span, [theta0, omega0], args=(b, A, omega, g, L), t_eval=t_eval) # Plot the pendulum's motion over time plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Angle (\u03b8)\") plt.plot(sol.t, sol.y[1], label=\"Angular Velocity (\u03c9)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"State Variables\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() 2. Phase Space Diagram The phase space plot shows how the system evolves over time, highlighting periodic or chaotic motion. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1], color='red') plt.xlabel(\"Angle (\u03b8)\") plt.ylabel(\"Angular Velocity (\u03c9)\") plt.title(\"Phase Space Diagram\") plt.grid() plt.show() 3. Poincar\u00e9 Section (Chaos Analysis) A Poincar\u00e9 section helps visualize transitions from regular to chaotic behavior by plotting states at fixed time intervals. times = np.arange(0, 50, 2*np.pi/omega) # Strobe at the driving frequency theta_poincare = np.interp(times, sol.t, sol.y[0]) omega_poincare = np.interp(times, sol.t, sol.y[1]) plt.figure(figsize=(6, 6)) plt.scatter(theta_poincare, omega_poincare, color='blue', s=5) plt.xlabel(\"Angle (\u03b8)\") plt.ylabel(\"Angular Velocity (\u03c9)\") plt.title(\"Poincar\u00e9 Section\") plt.grid() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation-forced-damped-pendulum","text":"","title":"Theoretical Foundation: Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-governing-equation","text":"The motion of a forced damped pendulum is described by: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(b\\) is the damping coefficient, - \\(g/L\\) represents the natural oscillation frequency, - \\(A \\cos(\\omega t)\\) is the external periodic force.","title":"1. Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-small-angle-approximation","text":"For small angles ( \\(\\theta \\approx 0\\) ), we use the approximation \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This reduces the system to a linear differential equation , which can be solved analytically.","title":"2. Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-resonance-and-energy-implications","text":"Natural Frequency: $$ \\omega_0 = \\sqrt{g/L} $$ Resonance Condition: When the driving frequency \\(\\omega\\) matches \\(\\omega_0\\) , the system experiences resonance , leading to large oscillations . Damping Effects: Higher damping ( \\(b\\) ) reduces oscillation amplitude and prevents unbounded energy growth.","title":"3. Resonance and Energy Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-influence-of-parameters-on-motion","text":"The behavior of the forced damped pendulum depends on key parameters: Damping Coefficient ( \\(b\\) ) Higher damping reduces oscillations and eventually brings the pendulum to rest. Lower damping allows sustained motion and can lead to resonance effects. Driving Amplitude ( \\(A\\) ) Small \\(A\\) results in steady periodic motion. Large \\(A\\) can induce irregular motion, leading to chaotic behavior. Driving Frequency ( \\(\\omega\\) ) When \\(\\omega \\approx \\omega_0\\) (natural frequency), resonance occurs, amplifying oscillations. At non-resonant frequencies, motion remains stable but varies in amplitude.","title":"1. Influence of Parameters on Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-transition-from-regular-to-chaotic-motion","text":"At low driving forces , the pendulum follows predictable periodic motion. Increasing \\(A\\) or adjusting \\(\\omega\\) can introduce nonlinear effects , where motion becomes quasi-periodic or chaotic . Chaotic motion means small differences in initial conditions lead to drastically different trajectories, making long-term prediction impossible.","title":"2. Transition from Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-physical-interpretation","text":"Regular motion is seen in clocks and metronomes where precise oscillations are required. Chaotic behavior appears in weather systems, electrical circuits, and biological rhythms , where nonlinearity dominates.","title":"3. Physical Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications-of-the-forced-damped-pendulum","text":"The forced damped pendulum model has widespread applications in engineering, physics, and real-world systems. Below are some key areas where it plays a crucial role:","title":"Practical Applications of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting-devices","text":"Example: Piezoelectric energy harvesters convert oscillations into electrical power. The pendulum\u2019s motion can be used to generate electricity in wearable sensors , self-powered devices , and vibrational energy systems .","title":"1. Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges","text":"Bridges experience oscillations due to wind forces and traffic loads . If the forcing frequency matches the bridge\u2019s natural frequency ( resonance ), it can cause dangerous oscillations (e.g., Tacoma Narrows Bridge collapse). Engineers use damping mechanisms to prevent excessive movement.","title":"2. Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-oscillating-electrical-circuits-rlc-circuits","text":"The forced damped pendulum is analogous to RLC circuits in electronics. In an RLC circuit: Damping ( \\(b\\) ) corresponds to electrical resistance. Natural frequency ( \\(\\omega_0\\) ) depends on inductance and capacitance. Driving force ( \\(A \\cos(\\omega t)\\) ) represents an AC voltage source. Understanding this analogy helps in designing filters, oscillators, and signal-processing devices .","title":"3. Oscillating Electrical Circuits (RLC Circuits)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-human-movement-and-biomechanics","text":"Example: The human gait involves periodic motion controlled by muscles and external forces. Rehabilitation therapy and prosthetic limb design apply the principles of forced oscillations.","title":"4. Human Movement and Biomechanics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum isn\u2019t just a theoretical concept\u2014it plays a vital role in engineering, biomechanics, and energy systems . Understanding these dynamics allows us to improve stability, efficiency, and safety in various real-world applications. \ud83d\ude80","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#implementation-simulating-the-forced-damped-pendulum","text":"We implement a numerical simulation of the forced damped pendulum using Python. The motion is governed by: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(b\\) is the damping coefficient, - \\(A \\cos(\\omega t)\\) is the external driving force, - \\(g/L\\) represents the natural oscillation frequency.","title":"Implementation: Simulating the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-numerical-simulation-runge-kutta-method","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the differential equation def pendulum(t, state, b, A, omega, g, L): theta, omega_dot = state dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.2 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency g = 9.81 # Gravity L = 1.0 # Pendulum length theta0 = 0.2 # Initial angle omega0 = 0.0 # Initial angular velocity t_span = (0, 50) # Time interval t_eval = np.linspace(*t_span, 1000) # Solve ODE using Runge-Kutta method sol = solve_ivp(pendulum, t_span, [theta0, omega0], args=(b, A, omega, g, L), t_eval=t_eval) # Plot the pendulum's motion over time plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Angle (\u03b8)\") plt.plot(sol.t, sol.y[1], label=\"Angular Velocity (\u03c9)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"State Variables\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"1. Numerical Simulation (Runge-Kutta Method)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-phase-space-diagram","text":"The phase space plot shows how the system evolves over time, highlighting periodic or chaotic motion. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1], color='red') plt.xlabel(\"Angle (\u03b8)\") plt.ylabel(\"Angular Velocity (\u03c9)\") plt.title(\"Phase Space Diagram\") plt.grid() plt.show()","title":"2. Phase Space Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-poincare-section-chaos-analysis","text":"A Poincar\u00e9 section helps visualize transitions from regular to chaotic behavior by plotting states at fixed time intervals. times = np.arange(0, 50, 2*np.pi/omega) # Strobe at the driving frequency theta_poincare = np.interp(times, sol.t, sol.y[0]) omega_poincare = np.interp(times, sol.t, sol.y[1]) plt.figure(figsize=(6, 6)) plt.scatter(theta_poincare, omega_poincare, color='blue', s=5) plt.xlabel(\"Angle (\u03b8)\") plt.ylabel(\"Angular Velocity (\u03c9)\") plt.title(\"Poincar\u00e9 Section\") plt.grid() plt.show()","title":"3. Poincar\u00e9 Section (Chaos Analysis)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Radius: Kepler's Third Law Task 1. Derivation of Kepler\u2019s Third Law For a small object orbiting a much larger central body in a circular orbit , the gravitational force provides the necessary centripetal force : \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] \\(G\\) : Gravitational constant \\(M\\) : Mass of the central body \\(m\\) : Mass of the orbiting object \\(r\\) : Orbital radius \\(v\\) : Orbital velocity Cancelling \\(m\\) and solving for velocity: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\(T\\) is the time to complete one full orbit: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This shows that: \\[ T^2 \\propto r^3 \\] which is Kepler\u2019s Third Law \u2014the square of the orbital period is proportional to the cube of the orbital radius. Task 2. Implications of Kepler\u2019s Third Law in Astronomy 1. Calculating Planetary Masses Kepler\u2019s Third Law states: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Rearranging to solve for the mass of the central body: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This allows astronomers to determine the mass of a star, planet, or moon by measuring the orbital period \\(T\\) and radius \\(r\\) of an orbiting object. Example: The mass of the Sun can be calculated using Earth's orbital data. Used to estimate the mass of exoplanets by analyzing their effect on nearby objects. 2. Measuring Distances in Space If the mass \\(M\\) is known, the equation: \\[ r^3 \\propto T^2 \\] can be used to calculate the distance of an orbiting body when the period \\(T\\) is observed. Helps determine the distances of moons around planets . Essential for mapping planetary systems and calculating exoplanet orbits . 3. Applications in Modern Astronomy Exoplanet Discovery : Detecting distant planets by observing how their gravitational pull affects the motion of nearby stars. Galaxy Mass Estimation : Using orbital speeds of stars to infer the mass distribution of galaxies. Satellite Navigation : Ensuring stable orbits for artificial satellites and space missions. Task 3. Real-World Examples of Kepler\u2019s Third Law 1. The Moon\u2019s Orbit Around Earth The Moon follows a nearly circular orbit around Earth. Using Kepler\u2019s Third Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] we can verify that the Moon\u2019s orbital period ( \\(T \\approx 27.3\\) days) and orbital radius ( \\(r \\approx 3.84 \\times 10^8\\) m) are consistent with Earth's mass ( \\(M = 5.97 \\times 10^{24}\\) kg). Key Insights: Confirms Earth's gravitational influence on the Moon. Helps predict lunar positions for astronomy and navigation. Useful in space missions , such as Apollo landings and satellite positioning. 2. Planetary Orbits in the Solar System For planets orbiting the Sun, Kepler\u2019s Third Law simplifies to: \\[ T^2 \\propto r^3 \\] This allows astronomers to predict planetary distances based on their orbital periods. Example: Earth vs. Mars Earth: \\(T = 1\\) year, \\(r = 1\\) AU (astronomical unit). Mars: \\(T \\approx 1.88\\) years. Applying Kepler\u2019s Third Law: $$ r^3 = T^2 \\Rightarrow r = \\sqrt[3]{(1.88)^2} \\approx 1.52 \\text{ AU} $$ which matches Mars\u2019 actual orbit. Key Applications: Planetary exploration : Calculating transfer orbits for space probes. Orbital predictions : Understanding gravitational interactions. Exoplanet studies : Inferring distances of newly discovered planets. 3. Practical Use in Astronomy and Space Science GPS Satellites : Kepler\u2019s Law ensures satellites maintain stable orbits. Space Missions : NASA and ESA use it for interplanetary travel. Binary Star Systems : Helps determine masses and distances of stars. Kepler\u2019s Third Law provides a powerful framework to study celestial mechanics, from our Moon\u2019s motion to planetary orbits and even distant exoplanets . Task 4. Computational Simulation of Circular Orbits 1. Objective This simulation models a circular orbit using Newton\u2019s laws and verifies Kepler\u2019s Third Law ( \\(T^2 \\propto r^3\\) ). 2. Python Implementation The code below simulates a planet orbiting a star and plots its trajectory while verifying the period-radius relationship. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # 1 Astronomical Unit (m) year = 3.154e7 # 1 year in seconds # Function to compute orbital period def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Generate radius values (0.4 AU to 5 AU) radii = np.linspace(0.4 * AU, 5 * AU, 50) periods = np.array([orbital_period(r) for r in radii]) # Verify Kepler's Law (T^2 vs. r^3) plt.figure(figsize=(8, 5)) plt.plot(radii**3, periods**2, 'o-', label=\"Simulated Data\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-radius-keplers-third-law","text":"","title":"Orbital Period and Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-1-derivation-of-keplers-third-law","text":"For a small object orbiting a much larger central body in a circular orbit , the gravitational force provides the necessary centripetal force : \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] \\(G\\) : Gravitational constant \\(M\\) : Mass of the central body \\(m\\) : Mass of the orbiting object \\(r\\) : Orbital radius \\(v\\) : Orbital velocity Cancelling \\(m\\) and solving for velocity: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\(T\\) is the time to complete one full orbit: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This shows that: \\[ T^2 \\propto r^3 \\] which is Kepler\u2019s Third Law \u2014the square of the orbital period is proportional to the cube of the orbital radius.","title":"Task 1. Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-2-implications-of-keplers-third-law-in-astronomy","text":"","title":"Task 2. Implications of Kepler\u2019s Third Law in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-calculating-planetary-masses","text":"Kepler\u2019s Third Law states: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] Rearranging to solve for the mass of the central body: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This allows astronomers to determine the mass of a star, planet, or moon by measuring the orbital period \\(T\\) and radius \\(r\\) of an orbiting object. Example: The mass of the Sun can be calculated using Earth's orbital data. Used to estimate the mass of exoplanets by analyzing their effect on nearby objects.","title":"1. Calculating Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-measuring-distances-in-space","text":"If the mass \\(M\\) is known, the equation: \\[ r^3 \\propto T^2 \\] can be used to calculate the distance of an orbiting body when the period \\(T\\) is observed. Helps determine the distances of moons around planets . Essential for mapping planetary systems and calculating exoplanet orbits .","title":"2. Measuring Distances in Space"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-applications-in-modern-astronomy","text":"Exoplanet Discovery : Detecting distant planets by observing how their gravitational pull affects the motion of nearby stars. Galaxy Mass Estimation : Using orbital speeds of stars to infer the mass distribution of galaxies. Satellite Navigation : Ensuring stable orbits for artificial satellites and space missions.","title":"3. Applications in Modern Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-3-real-world-examples-of-keplers-third-law","text":"","title":"Task 3. Real-World Examples of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moons-orbit-around-earth","text":"The Moon follows a nearly circular orbit around Earth. Using Kepler\u2019s Third Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] we can verify that the Moon\u2019s orbital period ( \\(T \\approx 27.3\\) days) and orbital radius ( \\(r \\approx 3.84 \\times 10^8\\) m) are consistent with Earth's mass ( \\(M = 5.97 \\times 10^{24}\\) kg).","title":"1. The Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#key-insights","text":"Confirms Earth's gravitational influence on the Moon. Helps predict lunar positions for astronomy and navigation. Useful in space missions , such as Apollo landings and satellite positioning.","title":"Key Insights:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-planetary-orbits-in-the-solar-system","text":"For planets orbiting the Sun, Kepler\u2019s Third Law simplifies to: \\[ T^2 \\propto r^3 \\] This allows astronomers to predict planetary distances based on their orbital periods.","title":"2. Planetary Orbits in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-earth-vs-mars","text":"Earth: \\(T = 1\\) year, \\(r = 1\\) AU (astronomical unit). Mars: \\(T \\approx 1.88\\) years. Applying Kepler\u2019s Third Law: $$ r^3 = T^2 \\Rightarrow r = \\sqrt[3]{(1.88)^2} \\approx 1.52 \\text{ AU} $$ which matches Mars\u2019 actual orbit.","title":"Example: Earth vs. Mars"},{"location":"1%20Physics/2%20Gravity/Problem_1/#key-applications","text":"Planetary exploration : Calculating transfer orbits for space probes. Orbital predictions : Understanding gravitational interactions. Exoplanet studies : Inferring distances of newly discovered planets.","title":"Key Applications:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-practical-use-in-astronomy-and-space-science","text":"GPS Satellites : Kepler\u2019s Law ensures satellites maintain stable orbits. Space Missions : NASA and ESA use it for interplanetary travel. Binary Star Systems : Helps determine masses and distances of stars. Kepler\u2019s Third Law provides a powerful framework to study celestial mechanics, from our Moon\u2019s motion to planetary orbits and even distant exoplanets .","title":"3. Practical Use in Astronomy and Space Science"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-4-computational-simulation-of-circular-orbits","text":"","title":"Task 4. Computational Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-objective","text":"This simulation models a circular orbit using Newton\u2019s laws and verifies Kepler\u2019s Third Law ( \\(T^2 \\propto r^3\\) ).","title":"1. Objective"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-python-implementation","text":"The code below simulates a planet orbiting a star and plots its trajectory while verifying the period-radius relationship. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # 1 Astronomical Unit (m) year = 3.154e7 # 1 year in seconds # Function to compute orbital period def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Generate radius values (0.4 AU to 5 AU) radii = np.linspace(0.4 * AU, 5 * AU, 50) periods = np.array([orbital_period(r) for r in radii]) # Verify Kepler's Law (T^2 vs. r^3) plt.figure(figsize=(8, 5)) plt.plot(radii**3, periods**2, 'o-', label=\"Simulated Data\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show()","title":"2. Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Task 1. Cosmic Velocities: Definitions and Meanings 1. First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the minimum velocity required for an object to stay in a stable circular orbit around a celestial body. It is given by: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] \\(G\\) : Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ) \\(M\\) : Mass of the celestial body \\(R\\) : Radius from the center of the celestial body \ud83d\udd39 Example : A satellite in low Earth orbit (~300 km altitude) moves at ~7.9 km/s . 2. Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum velocity needed to break free from a planet's gravity without further propulsion . It is derived from energy conservation: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] \ud83d\udd39 Example : Earth\u2019s escape velocity is ~11.2 km/s . If \\(v < v_2\\) : The object falls back. If \\(v = v_2\\) : The object reaches infinity but with zero velocity. If \\(v > v_2\\) : The object moves into hyperbolic orbit . 3. Third Cosmic Velocity (Solar System Escape Velocity) The third cosmic velocity is the minimum speed needed to escape the Sun\u2019s gravitational field from Earth\u2019s orbit. It is given by: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orb}}^2} \\] where: - \\(v_2\\) is Earth\u2019s escape velocity (11.2 km/s) . - \\(v_{\\text{orb}}\\) is Earth's orbital speed (29.8 km/s) . \ud83d\udd39 Example : The third cosmic velocity from Earth is ~42.1 km/s , used by interstellar missions like Voyager 1 & 2 . 4. Summary of Cosmic Velocities Cosmic Velocity Meaning Formula Example (Earth) First ( \\(v_1\\) ) Orbiting velocity \\(\\sqrt{G M / R}\\) 7.9 km/s Second ( \\(v_2\\) ) Escape velocity \\(\\sqrt{2 G M / R}\\) 11.2 km/s Third ( \\(v_3\\) ) Solar escape velocity \\(\\sqrt{v_2^2 + v_{\\text{orb}}^2}\\) 42.1 km/s Task 2. Mathematical Analysis of Cosmic Velocities 1. First Cosmic Velocity ( \\(v_1\\) ) \u2013 Orbital Velocity The first cosmic velocity is derived from the centripetal force equation : \\[ F_c = \\frac{m v_1^2}{R} \\] which must balance the gravitational force : \\[ F_g = \\frac{G M m}{R^2} \\] Setting \\(F_c = F_g\\) : \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Canceling \\(m\\) and solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Parameters Affecting \\(v_1\\) Mass ( \\(M\\) ) of the celestial body : Higher mass increases velocity. Radius ( \\(R\\) ) of orbit : Higher altitude lowers velocity. \ud83d\udd39 Example : A satellite in low Earth orbit (~300 km) moves at 7.9 km/s . 2. Second Cosmic Velocity ( \\(v_2\\) ) \u2013 Escape Velocity Derived from energy conservation : Kinetic Energy at launch : $$ KE = \\frac{1}{2} m v_2^2 $$ Gravitational Potential Energy : $$ PE = -\\frac{G M m}{R} $$ For escape, total energy must be zero : \\[ \\frac{1}{2} m v_2^2 - \\frac{G M m}{R} = 0 \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Parameters Affecting \\(v_2\\) Mass ( \\(M\\) ) : Higher mass increases escape velocity. Radius ( \\(R\\) ) : A larger radius decreases escape velocity. \ud83d\udd39 Example : Earth\u2019s escape velocity = 11.2 km/s . 3. Third Cosmic Velocity ( \\(v_3\\) ) \u2013 Solar System Escape Velocity To leave the Solar System , an object must escape both Earth's gravity and the Sun's gravity . The total velocity required is: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orb}}^2} \\] where: - \\(v_2\\) = Earth\u2019s escape velocity (11.2 km/s) - \\(v_{\\text{orb}}\\) = Earth\u2019s orbital speed (29.8 km/s) Parameters Affecting \\(v_3\\) Sun\u2019s gravity : A stronger gravitational pull increases \\(v_3\\) . Initial position : The farther from the Sun, the lower the required \\(v_3\\) . \ud83d\udd39 Example : Voyager 1 achieved ~42.1 km/s to escape the Solar System. 4. Summary of Velocity Dependence Velocity Formula Mass ( \\(M\\) ) Radius ( \\(R\\) ) Orbital Speed ( \\(v_{\\text{orb}}\\) ) First ( \\(v_1\\) ) \\(\\sqrt{G M / R}\\) \ud83d\udd3c Increases \ud83d\udd3d Decreases \u274c Not required Second ( \\(v_2\\) ) \\(\\sqrt{2 G M / R}\\) \ud83d\udd3c Increases \ud83d\udd3d Decreases \u274c Not required Third ( \\(v_3\\) ) \\(\\sqrt{v_2^2 + v_{\\text{orb}}^2}\\) \ud83d\udd3c Increases \ud83d\udd3d Decreases \ud83d\udd3c Increases Task 3. Calculation and Visualization of Cosmic Velocities for Different Planets 1. Introduction The first, second, and third cosmic velocities depend on the mass and radius of celestial bodies. We calculate these velocities for Earth, Mars, and Jupiter and visualize the differences. 2. Formulas for Cosmic Velocities Using the universal gravitational constant: \\[ G = 6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\] First Cosmic Velocity (Orbital Velocity): $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ Second Cosmic Velocity (Escape Velocity): $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ Third Cosmic Velocity (Solar System Escape): $$ v_3 = \\sqrt{v_2^2 + v_{\\text{orb}}^2} $$ where: - \\(M\\) = mass of the celestial body, - \\(R\\) = radius of the celestial body, - \\(v_{\\text{orb}}\\) = orbital velocity of the planet around the Sun. 3. Python Code for Calculations and Visualization import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) # Data for Earth, Mars, and Jupiter (mass in kg, radius in m, orbital velocity in m/s) planets = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"v_orb\": 2.978e4}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.389e6, \"v_orb\": 2.41e4}, \"Jupiter\":{\"M\": 1.898e27, \"R\": 6.9911e7, \"v_orb\": 1.307e4}, } # Calculate velocities velocities = {} for planet, data in planets.items(): M, R, v_orb = data[\"M\"], data[\"R\"], data[\"v_orb\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity v3 = np.sqrt(v2**2 + v_orb**2) # Third cosmic velocity velocities[planet] = [v1, v2, v3] # Convert to km/s for planet, v in velocities.items(): velocities[planet] = [round(v_i / 1000, 2) for v_i in v] # Print results print(\"Cosmic Velocities (km/s):\") for planet, v in velocities.items(): print(f\"{planet}: v1 = {v[0]} km/s, v2 = {v[1]} km/s, v3 = {v[2]} km/s\") # Visualization labels = [\"First Cosmic (v1)\", \"Second Cosmic (v2)\", \"Third Cosmic (v3)\"] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots() for i, planet in enumerate(planets.keys()): ax.bar(x + i * width, velocities[planet], width, label=planet) ax.set_xlabel(\"Cosmic Velocity Type\") ax.set_ylabel(\"Velocity (km/s)\") ax.set_title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") ax.set_xticks(x + width) ax.set_xticklabels(labels) ax.legend() plt.show() Cosmic Velocities (km/s) Earth - First Cosmic Velocity (v\u2081): 7.91 km/s - Second Cosmic Velocity (v\u2082): 11.19 km/s - Third Cosmic Velocity (v\u2083): 31.81 km/s Mars - First Cosmic Velocity (v\u2081): 3.55 km/s - Second Cosmic Velocity (v\u2082): 5.03 km/s - Third Cosmic Velocity (v\u2083): 24.62 km/s Jupiter - First Cosmic Velocity (v\u2081): 42.57 km/s - Second Cosmic Velocity (v\u2082): 60.2 km/s - Third Cosmic Velocity (v\u2083): 61.6 km/s Task 4. Importance of Cosmic Velocities in Space Exploration 1. Introduction Cosmic velocities define the energy required for spacecraft and satellites to move within and beyond planetary orbits. These velocities are critical for launching satellites, interplanetary travel, and even future interstellar missions. 2. Applications in Space Exploration 1st Cosmic Velocity (Orbital Velocity) \u2013 Satellites & Space Stations The first cosmic velocity ( \\(v_1\\) ) allows objects to maintain a stable orbit around a planet. Used for launching satellites (e.g., GPS, weather, and communication satellites). The International Space Station (ISS) orbits Earth at approximately 7.66 km/s , close to Earth's \\(v_1\\) . 2nd Cosmic Velocity (Escape Velocity) \u2013 Interplanetary Missions The second cosmic velocity ( \\(v_2\\) ) is needed to break free from a planet's gravitational pull. Required for missions like: Apollo Moon Missions (needed \\(v_2 = 11.2\\) km/s from Earth). Mars Rovers (Perseverance, Curiosity) \u2013 Escape from Earth, enter Mars\u2019 orbit. Jupiter and Outer Planet Missions (e.g., Juno spacecraft). 3rd Cosmic Velocity (Solar System Escape) \u2013 Deep Space & Interstellar Travel The third cosmic velocity ( \\(v_3\\) ) allows a spacecraft to leave the solar system. Examples: Voyager 1 & 2 \u2013 Left the solar system using gravity assists from Jupiter and Saturn. Parker Solar Probe \u2013 Fastest human-made object (700,000 km/h). Future interstellar missions (e.g., Breakthrough Starshot) require overcoming \\(v_3\\) for deep-space exploration. 3. Challenges & Future Prospects Fuel & Energy Requirements : Current propulsion methods rely on chemical rockets, which have limitations in reaching higher velocities. Gravity Assists : Spacecraft use planets like Jupiter for gravitational boosts to achieve \\(v_3\\) . Advanced Propulsion : Ion Thrusters (used on NASA\u2019s Dawn Mission). Nuclear Propulsion (potential for Mars and beyond). Light Sail Technologies (e.g., Breakthrough Starshot).","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-1-cosmic-velocities-definitions-and-meanings","text":"","title":"Task 1. Cosmic Velocities: Definitions and Meanings"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum velocity required for an object to stay in a stable circular orbit around a celestial body. It is given by: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] \\(G\\) : Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ) \\(M\\) : Mass of the celestial body \\(R\\) : Radius from the center of the celestial body \ud83d\udd39 Example : A satellite in low Earth orbit (~300 km altitude) moves at ~7.9 km/s .","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the minimum velocity needed to break free from a planet's gravity without further propulsion . It is derived from energy conservation: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\] \ud83d\udd39 Example : Earth\u2019s escape velocity is ~11.2 km/s . If \\(v < v_2\\) : The object falls back. If \\(v = v_2\\) : The object reaches infinity but with zero velocity. If \\(v > v_2\\) : The object moves into hyperbolic orbit .","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-solar-system-escape-velocity","text":"The third cosmic velocity is the minimum speed needed to escape the Sun\u2019s gravitational field from Earth\u2019s orbit. It is given by: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orb}}^2} \\] where: - \\(v_2\\) is Earth\u2019s escape velocity (11.2 km/s) . - \\(v_{\\text{orb}}\\) is Earth's orbital speed (29.8 km/s) . \ud83d\udd39 Example : The third cosmic velocity from Earth is ~42.1 km/s , used by interstellar missions like Voyager 1 & 2 .","title":"3. Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-summary-of-cosmic-velocities","text":"Cosmic Velocity Meaning Formula Example (Earth) First ( \\(v_1\\) ) Orbiting velocity \\(\\sqrt{G M / R}\\) 7.9 km/s Second ( \\(v_2\\) ) Escape velocity \\(\\sqrt{2 G M / R}\\) 11.2 km/s Third ( \\(v_3\\) ) Solar escape velocity \\(\\sqrt{v_2^2 + v_{\\text{orb}}^2}\\) 42.1 km/s","title":"4. Summary of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-2-mathematical-analysis-of-cosmic-velocities","text":"","title":"Task 2. Mathematical Analysis of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1-orbital-velocity","text":"The first cosmic velocity is derived from the centripetal force equation : \\[ F_c = \\frac{m v_1^2}{R} \\] which must balance the gravitational force : \\[ F_g = \\frac{G M m}{R^2} \\] Setting \\(F_c = F_g\\) : \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Canceling \\(m\\) and solving for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\]","title":"1. First Cosmic Velocity (\\(v_1\\)) \u2013 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-affecting-v_1","text":"Mass ( \\(M\\) ) of the celestial body : Higher mass increases velocity. Radius ( \\(R\\) ) of orbit : Higher altitude lowers velocity. \ud83d\udd39 Example : A satellite in low Earth orbit (~300 km) moves at 7.9 km/s .","title":"Parameters Affecting \\(v_1\\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2-escape-velocity","text":"Derived from energy conservation : Kinetic Energy at launch : $$ KE = \\frac{1}{2} m v_2^2 $$ Gravitational Potential Energy : $$ PE = -\\frac{G M m}{R} $$ For escape, total energy must be zero : \\[ \\frac{1}{2} m v_2^2 - \\frac{G M m}{R} = 0 \\] Solving for \\(v_2\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} \\]","title":"2. Second Cosmic Velocity (\\(v_2\\)) \u2013 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-affecting-v_2","text":"Mass ( \\(M\\) ) : Higher mass increases escape velocity. Radius ( \\(R\\) ) : A larger radius decreases escape velocity. \ud83d\udd39 Example : Earth\u2019s escape velocity = 11.2 km/s .","title":"Parameters Affecting \\(v_2\\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3-solar-system-escape-velocity","text":"To leave the Solar System , an object must escape both Earth's gravity and the Sun's gravity . The total velocity required is: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orb}}^2} \\] where: - \\(v_2\\) = Earth\u2019s escape velocity (11.2 km/s) - \\(v_{\\text{orb}}\\) = Earth\u2019s orbital speed (29.8 km/s)","title":"3. Third Cosmic Velocity (\\(v_3\\)) \u2013 Solar System Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-affecting-v_3","text":"Sun\u2019s gravity : A stronger gravitational pull increases \\(v_3\\) . Initial position : The farther from the Sun, the lower the required \\(v_3\\) . \ud83d\udd39 Example : Voyager 1 achieved ~42.1 km/s to escape the Solar System.","title":"Parameters Affecting \\(v_3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-summary-of-velocity-dependence","text":"Velocity Formula Mass ( \\(M\\) ) Radius ( \\(R\\) ) Orbital Speed ( \\(v_{\\text{orb}}\\) ) First ( \\(v_1\\) ) \\(\\sqrt{G M / R}\\) \ud83d\udd3c Increases \ud83d\udd3d Decreases \u274c Not required Second ( \\(v_2\\) ) \\(\\sqrt{2 G M / R}\\) \ud83d\udd3c Increases \ud83d\udd3d Decreases \u274c Not required Third ( \\(v_3\\) ) \\(\\sqrt{v_2^2 + v_{\\text{orb}}^2}\\) \ud83d\udd3c Increases \ud83d\udd3d Decreases \ud83d\udd3c Increases","title":"4. Summary of Velocity Dependence"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-3-calculation-and-visualization-of-cosmic-velocities-for-different-planets","text":"","title":"Task 3. Calculation and Visualization of Cosmic Velocities for Different Planets"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction","text":"The first, second, and third cosmic velocities depend on the mass and radius of celestial bodies. We calculate these velocities for Earth, Mars, and Jupiter and visualize the differences.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-formulas-for-cosmic-velocities","text":"Using the universal gravitational constant: \\[ G = 6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\] First Cosmic Velocity (Orbital Velocity): $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ Second Cosmic Velocity (Escape Velocity): $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ Third Cosmic Velocity (Solar System Escape): $$ v_3 = \\sqrt{v_2^2 + v_{\\text{orb}}^2} $$ where: - \\(M\\) = mass of the celestial body, - \\(R\\) = radius of the celestial body, - \\(v_{\\text{orb}}\\) = orbital velocity of the planet around the Sun.","title":"2. Formulas for Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-for-calculations-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) # Data for Earth, Mars, and Jupiter (mass in kg, radius in m, orbital velocity in m/s) planets = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"v_orb\": 2.978e4}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.389e6, \"v_orb\": 2.41e4}, \"Jupiter\":{\"M\": 1.898e27, \"R\": 6.9911e7, \"v_orb\": 1.307e4}, } # Calculate velocities velocities = {} for planet, data in planets.items(): M, R, v_orb = data[\"M\"], data[\"R\"], data[\"v_orb\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity v3 = np.sqrt(v2**2 + v_orb**2) # Third cosmic velocity velocities[planet] = [v1, v2, v3] # Convert to km/s for planet, v in velocities.items(): velocities[planet] = [round(v_i / 1000, 2) for v_i in v] # Print results print(\"Cosmic Velocities (km/s):\") for planet, v in velocities.items(): print(f\"{planet}: v1 = {v[0]} km/s, v2 = {v[1]} km/s, v3 = {v[2]} km/s\") # Visualization labels = [\"First Cosmic (v1)\", \"Second Cosmic (v2)\", \"Third Cosmic (v3)\"] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots() for i, planet in enumerate(planets.keys()): ax.bar(x + i * width, velocities[planet], width, label=planet) ax.set_xlabel(\"Cosmic Velocity Type\") ax.set_ylabel(\"Velocity (km/s)\") ax.set_title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") ax.set_xticks(x + width) ax.set_xticklabels(labels) ax.legend() plt.show()","title":"3. Python Code for Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-kms","text":"Earth - First Cosmic Velocity (v\u2081): 7.91 km/s - Second Cosmic Velocity (v\u2082): 11.19 km/s - Third Cosmic Velocity (v\u2083): 31.81 km/s Mars - First Cosmic Velocity (v\u2081): 3.55 km/s - Second Cosmic Velocity (v\u2082): 5.03 km/s - Third Cosmic Velocity (v\u2083): 24.62 km/s Jupiter - First Cosmic Velocity (v\u2081): 42.57 km/s - Second Cosmic Velocity (v\u2082): 60.2 km/s - Third Cosmic Velocity (v\u2083): 61.6 km/s","title":"Cosmic Velocities (km/s)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-4-importance-of-cosmic-velocities-in-space-exploration","text":"","title":"Task 4. Importance of Cosmic Velocities in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction_1","text":"Cosmic velocities define the energy required for spacecraft and satellites to move within and beyond planetary orbits. These velocities are critical for launching satellites, interplanetary travel, and even future interstellar missions.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-applications-in-space-exploration","text":"","title":"2. Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1st-cosmic-velocity-orbital-velocity-satellites-space-stations","text":"The first cosmic velocity ( \\(v_1\\) ) allows objects to maintain a stable orbit around a planet. Used for launching satellites (e.g., GPS, weather, and communication satellites). The International Space Station (ISS) orbits Earth at approximately 7.66 km/s , close to Earth's \\(v_1\\) .","title":"1st Cosmic Velocity (Orbital Velocity) \u2013 Satellites &amp; Space Stations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2nd-cosmic-velocity-escape-velocity-interplanetary-missions","text":"The second cosmic velocity ( \\(v_2\\) ) is needed to break free from a planet's gravitational pull. Required for missions like: Apollo Moon Missions (needed \\(v_2 = 11.2\\) km/s from Earth). Mars Rovers (Perseverance, Curiosity) \u2013 Escape from Earth, enter Mars\u2019 orbit. Jupiter and Outer Planet Missions (e.g., Juno spacecraft).","title":"2nd Cosmic Velocity (Escape Velocity) \u2013 Interplanetary Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3rd-cosmic-velocity-solar-system-escape-deep-space-interstellar-travel","text":"The third cosmic velocity ( \\(v_3\\) ) allows a spacecraft to leave the solar system. Examples: Voyager 1 & 2 \u2013 Left the solar system using gravity assists from Jupiter and Saturn. Parker Solar Probe \u2013 Fastest human-made object (700,000 km/h). Future interstellar missions (e.g., Breakthrough Starshot) require overcoming \\(v_3\\) for deep-space exploration.","title":"3rd Cosmic Velocity (Solar System Escape) \u2013 Deep Space &amp; Interstellar Travel"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-challenges-future-prospects","text":"Fuel & Energy Requirements : Current propulsion methods rely on chemical rockets, which have limitations in reaching higher velocities. Gravity Assists : Spacecraft use planets like Jupiter for gravitational boosts to achieve \\(v_3\\) . Advanced Propulsion : Ion Thrusters (used on NASA\u2019s Dawn Mission). Nuclear Propulsion (potential for Mars and beyond). Light Sail Technologies (e.g., Breakthrough Starshot).","title":"3. Challenges &amp; Future Prospects"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Task 1. Analysis of Payload Trajectories Near Earth 1. Types of Trajectories When a payload is released from a moving rocket, its path depends on initial velocity ( \\(v\\) ) and gravitational influence . The possible trajectories include: 1.1 Elliptical Orbit ( \\(v < v_2\\) ) If the payload\u2019s velocity is below escape velocity ( \\(v_2 = 11.2\\) km/s for Earth), it follows a closed elliptical orbit . If released at low altitude, it may eventually re-enter Earth's atmosphere due to air drag. Example: Satellites in Low Earth Orbit (LEO). 1.2 Parabolic Escape ( \\(v = v_2\\) ) If released exactly at escape velocity , the payload follows a parabolic trajectory and never returns to Earth. The payload moves infinitely far but slows asymptotically to zero velocity. Example: Theoretical minimum velocity for deep space travel. 1.3 Hyperbolic Escape ( \\(v > v_2\\) ) If released above escape velocity , it follows a hyperbolic trajectory and escapes Earth\u2019s gravity permanently. The excess velocity ( \\(v > v_2\\) ) determines the spacecraft\u2019s future motion. Example: Voyager probes leaving the solar system. 2. Governing Equations Using Newton\u2019s Law of Gravitation and Energy Conservation: Total Energy ( \\(E\\) ) determines trajectory type: $$ E = \\frac{1}{2} m v^2 - \\frac{G M m}{r} $$ \\(E < 0\\) \u2192 Elliptical Orbit \\(E = 0\\) \u2192 Parabolic Escape \\(E > 0\\) \u2192 Hyperbolic Escape Orbital Equation (for conic sections): $$ r(\\theta) = \\frac{p}{1 + e \\cos\\theta} $$ \\(e < 1\\) \u2192 Ellipse \\(e = 1\\) \u2192 Parabola \\(e > 1\\) \u2192 Hyperbola 3. Real-World Applications Satellite Deployment : Ensuring correct velocity for stable orbits. Interplanetary Travel : Using gravity assists for hyperbolic escapes. Re-Entry Scenarios : Predicting payload descent for controlled landings. Task 2. Numerical Analysis of Payload Trajectory 1. Problem Overview To determine the trajectory of a payload released near Earth, we use Newton's Second Law and Gravitational Force to compute its motion numerically. The motion is governed by: \\[ \\mathbf{F} = m \\mathbf{a} \\] where the gravitational force is: \\[ \\mathbf{F}_g = -\\frac{G M m}{r^2} \\hat{r} \\] We solve this using numerical integration methods like the Runge-Kutta (RK4) method . 2. Python Simulation The following script computes and visualizes the payload\u2019s trajectory based on initial conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Function to compute acceleration due to gravity def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions altitude = 400e3 # 400 km above Earth v_initial = 7800 # Initial velocity (m/s) angle = np.radians(45) # Release angle x0, y0 = R_Earth + altitude, 0 vx0, vy0 = v_initial * np.cos(angle), v_initial * np.sin(angle) # Time span and solving the equations t_span = (0, 6000) # Simulate for 6000 seconds initial_state = [x0, y0, vx0, vy0] sol = solve_ivp(equations, t_span, initial_state, method='RK45', t_eval=np.linspace(0, 6000, 1000)) # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], label=\"Payload Trajectory\") circle = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.3, label=\"Earth\") plt.gca().add_patch(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Numerical Simulation of Payload Trajectory\") plt.legend() plt.axis(\"equal\") plt.grid() plt.show() Task 3. Relation to Orbital Insertion, Reentry, and Escape 1. Orbital Insertion If a payload is released with a velocity close to the orbital velocity : $$ v_{orbital} = \\sqrt{\\frac{G M}{r}} $$ it will enter a stable orbit around Earth. - A velocity slightly below this value results in an elliptical orbit . - A velocity slightly above can push the payload into a higher orbit . 2. Reentry Scenarios If the velocity is too low , Earth's gravity dominates, pulling the payload back, leading to atmospheric reentry . The trajectory follows a parabolic or elliptical path before descent. Atmospheric drag and heat buildup occur, requiring a heat shield for protection . 3. Escape Scenarios If the payload exceeds escape velocity : $$ v_{escape} = \\sqrt{\\frac{2 G M}{r}} $$ it will break free from Earth's gravitational influence. - This results in a hyperbolic trajectory , allowing for interplanetary travel. - Space probes like Voyager 1 & 2 utilized escape velocity to leave the Solar System. Task 4. Simulation of Payload Motion Under Earth's Gravity Objective Develop a computational tool to simulate and visualize a payload\u2019s motion after being released from a moving rocket. The tool accounts for: - Earth's gravitational force. - Initial velocity and direction. - Different possible trajectories (elliptical, parabolic, hyperbolic). Python Simulation Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371e3 # Radius of Earth (m) # Function defining the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions altitude = 500e3 # 500 km above Earth initial_speed = 7800 # m/s (approximate low Earth orbit velocity) angle = np.radians(45) # Launch angle x0 = R + altitude y0 = 0 vx0 = initial_speed * np.cos(angle) vy0 = initial_speed * np.sin(angle) # Time span t_span = (0, 10000) # Simulate for 10,000 seconds t_eval = np.linspace(*t_span, num=500) # Time steps # Solve the equations of motion solution = solve_ivp(equations, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') # Extract results x, y = solution.y[0], solution.y[1] # Plot trajectory plt.figure(figsize=(8, 8)) earth = plt.Circle((0, 0), R, color='blue', alpha=0.3, label=\"Earth\") plt.gca().add_patch(earth) plt.plot(x, y, label=\"Payload Trajectory\", color='red') plt.xlabel(\"X Position (m)\") plt.ylabel(\"Y Position (m)\") plt.title(\"Payload Motion Under Earth's Gravity\") plt.legend() plt.axis(\"equal\") plt.grid() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-1-analysis-of-payload-trajectories-near-earth","text":"","title":"Task 1. Analysis of Payload Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-types-of-trajectories","text":"When a payload is released from a moving rocket, its path depends on initial velocity ( \\(v\\) ) and gravitational influence . The possible trajectories include:","title":"1. Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#11-elliptical-orbit-v-v_2","text":"If the payload\u2019s velocity is below escape velocity ( \\(v_2 = 11.2\\) km/s for Earth), it follows a closed elliptical orbit . If released at low altitude, it may eventually re-enter Earth's atmosphere due to air drag. Example: Satellites in Low Earth Orbit (LEO).","title":"1.1 Elliptical Orbit (\\(v &lt; v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_3/#12-parabolic-escape-v-v_2","text":"If released exactly at escape velocity , the payload follows a parabolic trajectory and never returns to Earth. The payload moves infinitely far but slows asymptotically to zero velocity. Example: Theoretical minimum velocity for deep space travel.","title":"1.2 Parabolic Escape (\\(v = v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_3/#13-hyperbolic-escape-v-v_2","text":"If released above escape velocity , it follows a hyperbolic trajectory and escapes Earth\u2019s gravity permanently. The excess velocity ( \\(v > v_2\\) ) determines the spacecraft\u2019s future motion. Example: Voyager probes leaving the solar system.","title":"1.3 Hyperbolic Escape (\\(v &gt; v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-governing-equations","text":"Using Newton\u2019s Law of Gravitation and Energy Conservation: Total Energy ( \\(E\\) ) determines trajectory type: $$ E = \\frac{1}{2} m v^2 - \\frac{G M m}{r} $$ \\(E < 0\\) \u2192 Elliptical Orbit \\(E = 0\\) \u2192 Parabolic Escape \\(E > 0\\) \u2192 Hyperbolic Escape Orbital Equation (for conic sections): $$ r(\\theta) = \\frac{p}{1 + e \\cos\\theta} $$ \\(e < 1\\) \u2192 Ellipse \\(e = 1\\) \u2192 Parabola \\(e > 1\\) \u2192 Hyperbola","title":"2. Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-real-world-applications","text":"Satellite Deployment : Ensuring correct velocity for stable orbits. Interplanetary Travel : Using gravity assists for hyperbolic escapes. Re-Entry Scenarios : Predicting payload descent for controlled landings.","title":"3. Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-2-numerical-analysis-of-payload-trajectory","text":"","title":"Task 2. Numerical Analysis of Payload Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-problem-overview","text":"To determine the trajectory of a payload released near Earth, we use Newton's Second Law and Gravitational Force to compute its motion numerically. The motion is governed by: \\[ \\mathbf{F} = m \\mathbf{a} \\] where the gravitational force is: \\[ \\mathbf{F}_g = -\\frac{G M m}{r^2} \\hat{r} \\] We solve this using numerical integration methods like the Runge-Kutta (RK4) method .","title":"1. Problem Overview"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-python-simulation","text":"The following script computes and visualizes the payload\u2019s trajectory based on initial conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Function to compute acceleration due to gravity def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions altitude = 400e3 # 400 km above Earth v_initial = 7800 # Initial velocity (m/s) angle = np.radians(45) # Release angle x0, y0 = R_Earth + altitude, 0 vx0, vy0 = v_initial * np.cos(angle), v_initial * np.sin(angle) # Time span and solving the equations t_span = (0, 6000) # Simulate for 6000 seconds initial_state = [x0, y0, vx0, vy0] sol = solve_ivp(equations, t_span, initial_state, method='RK45', t_eval=np.linspace(0, 6000, 1000)) # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[1], label=\"Payload Trajectory\") circle = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.3, label=\"Earth\") plt.gca().add_patch(circle) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Numerical Simulation of Payload Trajectory\") plt.legend() plt.axis(\"equal\") plt.grid() plt.show()","title":"2. Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-3-relation-to-orbital-insertion-reentry-and-escape","text":"","title":"Task 3. Relation to Orbital Insertion, Reentry, and Escape"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-orbital-insertion","text":"If a payload is released with a velocity close to the orbital velocity : $$ v_{orbital} = \\sqrt{\\frac{G M}{r}} $$ it will enter a stable orbit around Earth. - A velocity slightly below this value results in an elliptical orbit . - A velocity slightly above can push the payload into a higher orbit .","title":"1. Orbital Insertion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-reentry-scenarios","text":"If the velocity is too low , Earth's gravity dominates, pulling the payload back, leading to atmospheric reentry . The trajectory follows a parabolic or elliptical path before descent. Atmospheric drag and heat buildup occur, requiring a heat shield for protection .","title":"2. Reentry Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-escape-scenarios","text":"If the payload exceeds escape velocity : $$ v_{escape} = \\sqrt{\\frac{2 G M}{r}} $$ it will break free from Earth's gravitational influence. - This results in a hyperbolic trajectory , allowing for interplanetary travel. - Space probes like Voyager 1 & 2 utilized escape velocity to leave the Solar System.","title":"3. Escape Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-4-simulation-of-payload-motion-under-earths-gravity","text":"","title":"Task 4. Simulation of Payload Motion Under Earth's Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"Develop a computational tool to simulate and visualize a payload\u2019s motion after being released from a moving rocket. The tool accounts for: - Earth's gravitational force. - Initial velocity and direction. - Different possible trajectories (elliptical, parabolic, hyperbolic).","title":"Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371e3 # Radius of Earth (m) # Function defining the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions altitude = 500e3 # 500 km above Earth initial_speed = 7800 # m/s (approximate low Earth orbit velocity) angle = np.radians(45) # Launch angle x0 = R + altitude y0 = 0 vx0 = initial_speed * np.cos(angle) vy0 = initial_speed * np.sin(angle) # Time span t_span = (0, 10000) # Simulate for 10,000 seconds t_eval = np.linspace(*t_span, num=500) # Time steps # Solve the equations of motion solution = solve_ivp(equations, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') # Extract results x, y = solution.y[0], solution.y[1] # Plot trajectory plt.figure(figsize=(8, 8)) earth = plt.Circle((0, 0), R, color='blue', alpha=0.3, label=\"Earth\") plt.gca().add_patch(earth) plt.plot(x, y, label=\"Payload Trajectory\", color='red') plt.xlabel(\"X Position (m)\") plt.ylabel(\"Y Position (m)\") plt.title(\"Payload Motion Under Earth's Gravity\") plt.legend() plt.axis(\"equal\") plt.grid() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Understanding Interference Patterns When waves from multiple sources interact, they create constructive and destructive interference. The resulting wave displacement is given by: \\[ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{N} A \\sin \\left( k r_i - \\omega t \\right) \\] where: - \\(A\\) is the wave amplitude, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega\\) is the angular frequency, - \\(r_i\\) is the distance from the \\(i^{th}\\) source to \\((x,y)\\) . 2. Numerical Simulation The following Python script simulates the interference patterns created by point sources arranged in a regular polygon. import numpy as np import matplotlib.pyplot as plt # Parameters num_sides = 3 # Number of polygon sides (e.g., 3 for triangle) amplitude = 1.0 # Amplitude (A) of waves wavelength = 2.0 # Wavelength (\u03bb) radius = 5.0 # Radius of polygon (distance from center to sources) grid_size = 10.0 # Size of simulation grid time = 0 # Time instant for visualization # Generate polygon source coordinates angles = np.linspace(0, 2*np.pi, num_sides, endpoint=False) sources_x = radius * np.cos(angles) # X-coordinates of sources sources_y = radius * np.sin(angles) # Y-coordinates of sources # Create grid for wave simulation x = np.linspace(-grid_size, grid_size, 500) y = np.linspace(-grid_size, grid_size, 500) X, Y = np.meshgrid(x, y) # Compute wave displacement at each grid point def wave_displacement(x, y, t): total = 0.0 for sx, sy in zip(sources_x, sources_y): distance = np.sqrt((x - sx)**2 + (y - sy)**2) total += amplitude * np.sin(2 * np.pi * distance / wavelength - t) return total Z = wave_displacement(X, Y, time) # Plot interference pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Z, levels=50, cmap='RdYlBu') plt.colorbar(label='Wave Displacement', shrink=0.8) plt.scatter(sources_x, sources_y, c='black', s=50, marker='o', label='Wave Sources') plt.title(f'Interference Pattern for {num_sides}-Sided Polygon Wave Sources') plt.xlabel('X Position') plt.ylabel('Y Position') plt.xlim(-grid_size, grid_size) plt.ylim(-grid_size, grid_size) plt.axhline(0, color='white', linestyle='--', linewidth=0.5) plt.axvline(0, color='white', linestyle='--', linewidth=0.5) plt.gca().set_aspect('equal') plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-understanding-interference-patterns","text":"When waves from multiple sources interact, they create constructive and destructive interference. The resulting wave displacement is given by: \\[ \\eta_{\\text{sum}}(x,y,t) = \\sum_{i=1}^{N} A \\sin \\left( k r_i - \\omega t \\right) \\] where: - \\(A\\) is the wave amplitude, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega\\) is the angular frequency, - \\(r_i\\) is the distance from the \\(i^{th}\\) source to \\((x,y)\\) .","title":"1. Understanding Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-numerical-simulation","text":"The following Python script simulates the interference patterns created by point sources arranged in a regular polygon. import numpy as np import matplotlib.pyplot as plt # Parameters num_sides = 3 # Number of polygon sides (e.g., 3 for triangle) amplitude = 1.0 # Amplitude (A) of waves wavelength = 2.0 # Wavelength (\u03bb) radius = 5.0 # Radius of polygon (distance from center to sources) grid_size = 10.0 # Size of simulation grid time = 0 # Time instant for visualization # Generate polygon source coordinates angles = np.linspace(0, 2*np.pi, num_sides, endpoint=False) sources_x = radius * np.cos(angles) # X-coordinates of sources sources_y = radius * np.sin(angles) # Y-coordinates of sources # Create grid for wave simulation x = np.linspace(-grid_size, grid_size, 500) y = np.linspace(-grid_size, grid_size, 500) X, Y = np.meshgrid(x, y) # Compute wave displacement at each grid point def wave_displacement(x, y, t): total = 0.0 for sx, sy in zip(sources_x, sources_y): distance = np.sqrt((x - sx)**2 + (y - sy)**2) total += amplitude * np.sin(2 * np.pi * distance / wavelength - t) return total Z = wave_displacement(X, Y, time) # Plot interference pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Z, levels=50, cmap='RdYlBu') plt.colorbar(label='Wave Displacement', shrink=0.8) plt.scatter(sources_x, sources_y, c='black', s=50, marker='o', label='Wave Sources') plt.title(f'Interference Pattern for {num_sides}-Sided Polygon Wave Sources') plt.xlabel('X Position') plt.ylabel('Y Position') plt.xlim(-grid_size, grid_size) plt.ylim(-grid_size, grid_size) plt.axhline(0, color='white', linestyle='--', linewidth=0.5) plt.axvline(0, color='white', linestyle='--', linewidth=0.5) plt.gca().set_aspect('equal') plt.legend() plt.show()","title":"2. Numerical Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 1. Applications of the Lorentz Force Overview The Lorentz force describes how charged particles move in electric and magnetic fields: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] It's essential in many physics and engineering systems. Key Applications Particle Accelerators Use electric fields to accelerate particles. Magnetic fields steer them in circular paths (e.g., cyclotrons, synchrotrons). Mass Spectrometers Separate ions based on mass-to-charge ratio using magnetic deflection: \\[ r = \\frac{mv}{qB} \\] Plasma Confinement Magnetic fields control hot plasma in fusion reactors (e.g., tokamaks). Charged particles follow spiral paths due to Lorentz force. E and B Field Roles \\(\\vec{E}\\) field: changes particle speed. \\(\\vec{B}\\) field: changes direction, not speed. 2.Simulating Particle Motion Under Lorentz Force Overview The Lorentz force governs the motion of charged particles: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] We simulate this using the Euler method , updating velocity and position step-by-step. Python Simulation (Euler Method) import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step (s) T = 50 # Total simulation time steps = int(T / dt) # Initial conditions r = np.zeros((steps, 3)) # Position [x, y, z] v = np.zeros((steps, 3)) # Velocity [vx, vy, vz] r[0] = [0.0, 0.0, 0.0] v[0] = [1.0, 1.0, 0.0] # Choose fields here: E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field (change for testing different cases) # Euler integration for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i+1] = v[i] + a * dt r[i+1] = r[i] + v[i] * dt # Plot trajectory in 3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2]) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_title('Trajectory of a Charged Particle') plt.show() 3. Parameter Exploration Goal Explore how particle motion changes based on: Electric field ( \\(\\vec{E}\\) ) Magnetic field ( \\(\\vec{B}\\) ) Initial velocity ( \\(\\vec{v}\\) ) Particle charge ( \\(q\\) ) and mass ( \\(m\\) ) Updated Simulation Code import numpy as np import matplotlib.pyplot as plt # Adjustable parameters q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 1.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) v = np.array([1.0, 1.0, 0.0]) # Initial velocity (m/s) r = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Time settings dt = 0.01 steps = 1000 trajectory = np.zeros((steps, 3)) # Euler integration loop for i in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt trajectory[i] = r # Plotting the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2]) ax.set_title(\"Trajectory with Variable Parameters\") ax.set_xlabel(\"X Position\") ax.set_ylabel(\"Y Position\") ax.set_zlabel(\"Z Position\") plt.show() 4. Visualization of Particle Motion Goal Visualize the trajectory of a charged particle under various electromagnetic field setups, and highlight key physical features such as: Larmor radius (radius of circular motion in magnetic field) Drift velocity (in crossed electric and magnetic fields) Python Code with 2D and 3D Plots import numpy as np import matplotlib.pyplot as plt # Parameters (you can modify for each case) q = 1.0 m = 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field v = np.array([0.0, 1.0, 0.0]) # Initial velocity r = np.array([0.0, 0.0, 0.0]) # Initial position # Time settings dt = 0.01 steps = 1000 trajectory = np.zeros((steps, 3)) # Euler loop for i in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt trajectory[i] = r # Calculate Larmor radius: r_L = mv_perp / (qB) v_perp = np.linalg.norm(np.cross(v, B) / np.linalg.norm(B)) if np.linalg.norm(B) != 0 else 0 r_L = (m * v_perp) / (q * np.linalg.norm(B)) if np.linalg.norm(B) != 0 else 0 # Drift velocity (E \u00d7 B) / B\u00b2 if np.linalg.norm(B) != 0: v_drift = np.cross(E, B) / np.linalg.norm(B)**2 else: v_drift = np.zeros(3) # --- 2D Plot (X vs Y) --- plt.figure(figsize=(6, 6)) plt.plot(trajectory[:, 0], trajectory[:, 1], label='Trajectory') plt.title(\"2D Trajectory (X vs Y)\") plt.xlabel(\"X Position\") plt.ylabel(\"Y Position\") plt.grid(True) plt.axis(\"equal\") plt.legend() plt.annotate(f\"Larmor radius \u2248 {r_L:.2f}\", xy=(0.05, 0.95), xycoords='axes fraction', fontsize=10) plt.annotate(f\"Drift velocity \u2248 {v_drift}\", xy=(0.05, 0.90), xycoords='axes fraction', fontsize=10) plt.show() # --- 3D Plot --- from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], label='3D Trajectory') ax.set_title(\"3D Trajectory of Charged Particle\") ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") ax.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-applications-of-the-lorentz-force","text":"","title":"1. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#overview","text":"The Lorentz force describes how charged particles move in electric and magnetic fields: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] It's essential in many physics and engineering systems.","title":"Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-applications","text":"","title":"Key Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-accelerators","text":"Use electric fields to accelerate particles. Magnetic fields steer them in circular paths (e.g., cyclotrons, synchrotrons).","title":"Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#mass-spectrometers","text":"Separate ions based on mass-to-charge ratio using magnetic deflection: \\[ r = \\frac{mv}{qB} \\]","title":"Mass Spectrometers"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plasma-confinement","text":"Magnetic fields control hot plasma in fusion reactors (e.g., tokamaks). Charged particles follow spiral paths due to Lorentz force.","title":"Plasma Confinement"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#e-and-b-field-roles","text":"\\(\\vec{E}\\) field: changes particle speed. \\(\\vec{B}\\) field: changes direction, not speed.","title":"E and B Field Roles"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2simulating-particle-motion-under-lorentz-force","text":"","title":"2.Simulating Particle Motion Under Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#overview_1","text":"The Lorentz force governs the motion of charged particles: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] We simulate this using the Euler method , updating velocity and position step-by-step.","title":"Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-euler-method","text":"import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step (s) T = 50 # Total simulation time steps = int(T / dt) # Initial conditions r = np.zeros((steps, 3)) # Position [x, y, z] v = np.zeros((steps, 3)) # Velocity [vx, vy, vz] r[0] = [0.0, 0.0, 0.0] v[0] = [1.0, 1.0, 0.0] # Choose fields here: E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field (change for testing different cases) # Euler integration for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i+1] = v[i] + a * dt r[i+1] = r[i] + v[i] * dt # Plot trajectory in 3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2]) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_title('Trajectory of a Charged Particle') plt.show()","title":"Python Simulation (Euler Method)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#goal","text":"Explore how particle motion changes based on: Electric field ( \\(\\vec{E}\\) ) Magnetic field ( \\(\\vec{B}\\) ) Initial velocity ( \\(\\vec{v}\\) ) Particle charge ( \\(q\\) ) and mass ( \\(m\\) )","title":"Goal"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#updated-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Adjustable parameters q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 1.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) v = np.array([1.0, 1.0, 0.0]) # Initial velocity (m/s) r = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Time settings dt = 0.01 steps = 1000 trajectory = np.zeros((steps, 3)) # Euler integration loop for i in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt trajectory[i] = r # Plotting the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2]) ax.set_title(\"Trajectory with Variable Parameters\") ax.set_xlabel(\"X Position\") ax.set_ylabel(\"Y Position\") ax.set_zlabel(\"Z Position\") plt.show()","title":"Updated Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization-of-particle-motion","text":"","title":"4. Visualization of Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#goal_1","text":"Visualize the trajectory of a charged particle under various electromagnetic field setups, and highlight key physical features such as: Larmor radius (radius of circular motion in magnetic field) Drift velocity (in crossed electric and magnetic fields)","title":"Goal"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-with-2d-and-3d-plots","text":"import numpy as np import matplotlib.pyplot as plt # Parameters (you can modify for each case) q = 1.0 m = 1.0 E = np.array([1.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field v = np.array([0.0, 1.0, 0.0]) # Initial velocity r = np.array([0.0, 0.0, 0.0]) # Initial position # Time settings dt = 0.01 steps = 1000 trajectory = np.zeros((steps, 3)) # Euler loop for i in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt trajectory[i] = r # Calculate Larmor radius: r_L = mv_perp / (qB) v_perp = np.linalg.norm(np.cross(v, B) / np.linalg.norm(B)) if np.linalg.norm(B) != 0 else 0 r_L = (m * v_perp) / (q * np.linalg.norm(B)) if np.linalg.norm(B) != 0 else 0 # Drift velocity (E \u00d7 B) / B\u00b2 if np.linalg.norm(B) != 0: v_drift = np.cross(E, B) / np.linalg.norm(B)**2 else: v_drift = np.zeros(3) # --- 2D Plot (X vs Y) --- plt.figure(figsize=(6, 6)) plt.plot(trajectory[:, 0], trajectory[:, 1], label='Trajectory') plt.title(\"2D Trajectory (X vs Y)\") plt.xlabel(\"X Position\") plt.ylabel(\"Y Position\") plt.grid(True) plt.axis(\"equal\") plt.legend() plt.annotate(f\"Larmor radius \u2248 {r_L:.2f}\", xy=(0.05, 0.95), xycoords='axes fraction', fontsize=10) plt.annotate(f\"Drift velocity \u2248 {v_drift}\", xy=(0.05, 0.90), xycoords='axes fraction', fontsize=10) plt.show() # --- 3D Plot --- from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], label='3D Trajectory') ax.set_title(\"3D Trajectory of Charged Particle\") ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") ax.legend() plt.show()","title":"Python Code with 2D and 3D Plots"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Calculation Using Graph Theory Overview Calculating equivalent resistance is crucial in circuit analysis, especially for complex circuits where repeated series and parallel reductions become cumbersome. By representing the circuit as a graph where: - Nodes are junctions, - Edges are resistors (weighted by their resistance value), we can simplify the network iteratively using graph theoretic methods. This approach enables automated analysis and deeper insights into the interplay between electrical and mathematical concepts. Option 1: Algorithm Description and Pseudocode 1. Theoretical Foundation The algorithm relies on two main operations: - Series Reduction: If a node is connected to exactly two other nodes, the resistors connecting them are in series and can be combined: $$ R_{eq} = R_1 + R_2 $$ Parallel Reduction: If two nodes are connected by more than one resistor, they are in parallel. Their equivalent resistance is computed as: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} $$ These operations are applied iteratively until the graph is reduced to a single edge representing the overall equivalent resistance. 2. Pseudocode function calculate_equivalent_resistance(graph): while graph has more than one node: for each node in graph: if node has exactly two neighbors: // Series reduction R_eq = R1 + R2 // Resistances from node to its two neighbors merge these nodes and update graph accordingly for each pair of nodes connected by multiple edges: // Parallel reduction R_eq = 1 / (sum(1/R_i for all edges between the nodes)) replace the parallel edges with a single edge of resistance R_eq return the resistance of the final edge Option 2: Full Implementation (Python) Below is an example Python implementation using the networkx library for graph manipulation: import networkx as nx def combine_series_resistors(graph): \"\"\" Identifies and combines resistors in series. If a node (other than start/end) has exactly two connections, its resistors are in series and are replaced by a single equivalent resistor. \"\"\" changed = True while changed: changed = False for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: n1, n2 = neighbors[0], neighbors[1] # Check if the node is not a terminal (start/end) node if graph.degree(node) == 2: # Get series resistances r1 = graph[node][n1]['resistance'] r2 = graph[node][n2]['resistance'] req = r1 + r2 # Add new edge with combined resistance if graph.has_edge(n1, n2): # If an edge already exists, treat them as parallel later graph.add_edge(n1, n2, resistance=req, series_added=True) else: graph.add_edge(n1, n2, resistance=req) graph.remove_node(node) changed = True break return changed def combine_parallel_resistors(graph): \"\"\" Identifies and combines resistors in parallel. For any pair of nodes with multiple edges, computes the equivalent resistance: 1/R_eq = 1/R_1 + 1/R_2 + ... + 1/R_n \"\"\" changed = True while changed: changed = False edges = list(graph.edges(data=True)) edge_map = {} # Group edges by unordered node pair for u, v, data in edges: key = tuple(sorted([u, v])) edge_map.setdefault(key, []).append(data['resistance']) for (u, v), resistances in edge_map.items(): if len(resistances) > 1: req = 1 / sum(1 / r for r in resistances) # Remove all parallel edges graph.remove_edges_from([(u, v) for _ in resistances]) graph.add_edge(u, v, resistance=req) changed = True break return changed def equivalent_resistance(graph, start, end): \"\"\" Iteratively simplifies the circuit graph until only one equivalent resistor remains between the start and end nodes. \"\"\" # Continuously apply series and parallel reductions while graph.number_of_nodes() > 2: series_changed = combine_series_resistors(graph) parallel_changed = combine_parallel_resistors(graph) if not (series_changed or parallel_changed): break # No further reduction is possible return graph[start][end]['resistance'] if graph.has_edge(start, end) else None # --- Example Configurations --- # Example 1: Simple Series G1 = nx.Graph() # A - B - C G1.add_edge('A', 'B', resistance=5) G1.add_edge('B', 'C', resistance=10) print(\"Series Example, Equivalent Resistance (A to C):\", equivalent_resistance(G1, 'A', 'C')) # Example 2: Series and Parallel Combination G2 = nx.Graph() # A - B - C with an additional direct A-C resistor G2.add_edge('A', 'B', resistance=5) G2.add_edge('B', 'C', resistance=10) G2.add_edge('A', 'C', resistance=6) print(\"Series/Parallel Example, Equivalent Resistance (A to C):\", equivalent_resistance(G2, 'A', 'C')) # Example 3: Complex Graph with Multiple Cycles G3 = nx.Graph() # Circuit diagram: A, B, C, D nodes with multiple interconnections G3.add_edge('A', 'B', resistance=4) G3.add_edge('B', 'C', resistance=6) G3.add_edge('C', 'D', resistance=8) G3.add_edge('A', 'D', resistance=10) G3.add_edge('B', 'D', resistance=5) print(\"Complex Graph Example, Equivalent Resistance (A to D):\", equivalent_resistance(G3, 'A', 'D')) Series Example, Equivalent Resistance (A to C): 15 Series/Parallel Example, Equivalent Resistance (A to C): None Complex Graph Example, Equivalent Resistance (A to D): None Equivalent Resistance Calculation with Visualization This implementation uses graph theory to calculate the equivalent resistance of a circuit. The circuit is represented as a graph where nodes are junctions and edges are resistors (weighted with their resistance). The algorithm iteratively reduces series and parallel resistor combinations until only one equivalent resistor remains between the start and end nodes. Finally, a visualization is produced using networkx and matplotlib . import networkx as nx import matplotlib.pyplot as plt def combine_series_resistors(graph): \"\"\" Identifies and combines resistors in series. If a node has exactly two neighbors (and is not a terminal), its incident resistors are in series and can be replaced by their sum. \"\"\" changed = True while changed: changed = False for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: n1, n2 = neighbors[0], neighbors[1] if graph.degree(node) == 2: # Node is only connected to these two nodes r1 = graph[node][n1]['resistance'] r2 = graph[node][n2]['resistance'] req = r1 + r2 # Add an edge between n1 and n2 with the combined resistance if graph.has_edge(n1, n2): # If an edge already exists, parallel reduction will handle it later. graph.add_edge(n1, n2, resistance=req, series_added=True) else: graph.add_edge(n1, n2, resistance=req) graph.remove_node(node) changed = True break return changed def combine_parallel_resistors(graph): \"\"\" Identifies and combines resistors in parallel. If two nodes are connected by more than one edge, calculate the equivalent resistance using the formula: 1/R_eq = 1/R1 + 1/R2 + ... + 1/Rn. \"\"\" changed = True while changed: changed = False edges = list(graph.edges(data=True)) edge_map = {} for u, v, data in edges: key = tuple(sorted([u, v])) edge_map.setdefault(key, []).append(data['resistance']) for (u, v), resistances in edge_map.items(): if len(resistances) > 1: req = 1 / sum(1 / r for r in resistances) # Remove all parallel edges and add a single equivalent edge graph.remove_edges_from([(u, v) for _ in resistances]) graph.add_edge(u, v, resistance=req) changed = True break return changed def equivalent_resistance(graph, start, end): \"\"\" Iteratively simplifies the circuit graph until only one equivalent resistor remains between the start and end nodes. \"\"\" while graph.number_of_nodes() > 2: series_changed = combine_series_resistors(graph) parallel_changed = combine_parallel_resistors(graph) if not (series_changed or parallel_changed): break # No further reduction possible if graph.has_edge(start, end): return graph[start][end]['resistance'] else: return None # ----- Example Usage ----- # Construct a sample circuit graph graph = nx.Graph() # Example circuit: # Nodes: A, B, C, D with multiple series and parallel connections. graph.add_edge('A', 'B', resistance=5) graph.add_edge('B', 'C', resistance=10) graph.add_edge('C', 'D', resistance=15) graph.add_edge('A', 'D', resistance=6) graph.add_edge('B', 'D', resistance=3) # Compute the equivalent resistance between nodes A and D. eq_res = equivalent_resistance(graph, 'A', 'D') print(\"Equivalent Resistance between A and D:\", eq_res) # ----- Visualization of the Simplified Circuit Graph ----- pos = nx.spring_layout(graph) # Compute a layout for the graph nx.draw(graph, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=500) labels = nx.get_edge_attributes(graph, 'resistance') nx.draw_networkx_edge_labels(graph, pos, edge_labels=labels) plt.title(\"Simplified Circuit Graph with Resistances\") plt.show()","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-calculation-using-graph-theory","text":"","title":"Equivalent Resistance Calculation Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#overview","text":"Calculating equivalent resistance is crucial in circuit analysis, especially for complex circuits where repeated series and parallel reductions become cumbersome. By representing the circuit as a graph where: - Nodes are junctions, - Edges are resistors (weighted by their resistance value), we can simplify the network iteratively using graph theoretic methods. This approach enables automated analysis and deeper insights into the interplay between electrical and mathematical concepts.","title":"Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-1-algorithm-description-and-pseudocode","text":"","title":"Option 1: Algorithm Description and Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-theoretical-foundation","text":"The algorithm relies on two main operations: - Series Reduction: If a node is connected to exactly two other nodes, the resistors connecting them are in series and can be combined: $$ R_{eq} = R_1 + R_2 $$ Parallel Reduction: If two nodes are connected by more than one resistor, they are in parallel. Their equivalent resistance is computed as: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} $$ These operations are applied iteratively until the graph is reduced to a single edge representing the overall equivalent resistance.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-pseudocode","text":"function calculate_equivalent_resistance(graph): while graph has more than one node: for each node in graph: if node has exactly two neighbors: // Series reduction R_eq = R1 + R2 // Resistances from node to its two neighbors merge these nodes and update graph accordingly for each pair of nodes connected by multiple edges: // Parallel reduction R_eq = 1 / (sum(1/R_i for all edges between the nodes)) replace the parallel edges with a single edge of resistance R_eq return the resistance of the final edge","title":"2. Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-2-full-implementation-python","text":"Below is an example Python implementation using the networkx library for graph manipulation: import networkx as nx def combine_series_resistors(graph): \"\"\" Identifies and combines resistors in series. If a node (other than start/end) has exactly two connections, its resistors are in series and are replaced by a single equivalent resistor. \"\"\" changed = True while changed: changed = False for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: n1, n2 = neighbors[0], neighbors[1] # Check if the node is not a terminal (start/end) node if graph.degree(node) == 2: # Get series resistances r1 = graph[node][n1]['resistance'] r2 = graph[node][n2]['resistance'] req = r1 + r2 # Add new edge with combined resistance if graph.has_edge(n1, n2): # If an edge already exists, treat them as parallel later graph.add_edge(n1, n2, resistance=req, series_added=True) else: graph.add_edge(n1, n2, resistance=req) graph.remove_node(node) changed = True break return changed def combine_parallel_resistors(graph): \"\"\" Identifies and combines resistors in parallel. For any pair of nodes with multiple edges, computes the equivalent resistance: 1/R_eq = 1/R_1 + 1/R_2 + ... + 1/R_n \"\"\" changed = True while changed: changed = False edges = list(graph.edges(data=True)) edge_map = {} # Group edges by unordered node pair for u, v, data in edges: key = tuple(sorted([u, v])) edge_map.setdefault(key, []).append(data['resistance']) for (u, v), resistances in edge_map.items(): if len(resistances) > 1: req = 1 / sum(1 / r for r in resistances) # Remove all parallel edges graph.remove_edges_from([(u, v) for _ in resistances]) graph.add_edge(u, v, resistance=req) changed = True break return changed def equivalent_resistance(graph, start, end): \"\"\" Iteratively simplifies the circuit graph until only one equivalent resistor remains between the start and end nodes. \"\"\" # Continuously apply series and parallel reductions while graph.number_of_nodes() > 2: series_changed = combine_series_resistors(graph) parallel_changed = combine_parallel_resistors(graph) if not (series_changed or parallel_changed): break # No further reduction is possible return graph[start][end]['resistance'] if graph.has_edge(start, end) else None # --- Example Configurations --- # Example 1: Simple Series G1 = nx.Graph() # A - B - C G1.add_edge('A', 'B', resistance=5) G1.add_edge('B', 'C', resistance=10) print(\"Series Example, Equivalent Resistance (A to C):\", equivalent_resistance(G1, 'A', 'C')) # Example 2: Series and Parallel Combination G2 = nx.Graph() # A - B - C with an additional direct A-C resistor G2.add_edge('A', 'B', resistance=5) G2.add_edge('B', 'C', resistance=10) G2.add_edge('A', 'C', resistance=6) print(\"Series/Parallel Example, Equivalent Resistance (A to C):\", equivalent_resistance(G2, 'A', 'C')) # Example 3: Complex Graph with Multiple Cycles G3 = nx.Graph() # Circuit diagram: A, B, C, D nodes with multiple interconnections G3.add_edge('A', 'B', resistance=4) G3.add_edge('B', 'C', resistance=6) G3.add_edge('C', 'D', resistance=8) G3.add_edge('A', 'D', resistance=10) G3.add_edge('B', 'D', resistance=5) print(\"Complex Graph Example, Equivalent Resistance (A to D):\", equivalent_resistance(G3, 'A', 'D')) Series Example, Equivalent Resistance (A to C): 15 Series/Parallel Example, Equivalent Resistance (A to C): None Complex Graph Example, Equivalent Resistance (A to D): None","title":"Option 2: Full Implementation (Python)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-calculation-with-visualization","text":"This implementation uses graph theory to calculate the equivalent resistance of a circuit. The circuit is represented as a graph where nodes are junctions and edges are resistors (weighted with their resistance). The algorithm iteratively reduces series and parallel resistor combinations until only one equivalent resistor remains between the start and end nodes. Finally, a visualization is produced using networkx and matplotlib . import networkx as nx import matplotlib.pyplot as plt def combine_series_resistors(graph): \"\"\" Identifies and combines resistors in series. If a node has exactly two neighbors (and is not a terminal), its incident resistors are in series and can be replaced by their sum. \"\"\" changed = True while changed: changed = False for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: n1, n2 = neighbors[0], neighbors[1] if graph.degree(node) == 2: # Node is only connected to these two nodes r1 = graph[node][n1]['resistance'] r2 = graph[node][n2]['resistance'] req = r1 + r2 # Add an edge between n1 and n2 with the combined resistance if graph.has_edge(n1, n2): # If an edge already exists, parallel reduction will handle it later. graph.add_edge(n1, n2, resistance=req, series_added=True) else: graph.add_edge(n1, n2, resistance=req) graph.remove_node(node) changed = True break return changed def combine_parallel_resistors(graph): \"\"\" Identifies and combines resistors in parallel. If two nodes are connected by more than one edge, calculate the equivalent resistance using the formula: 1/R_eq = 1/R1 + 1/R2 + ... + 1/Rn. \"\"\" changed = True while changed: changed = False edges = list(graph.edges(data=True)) edge_map = {} for u, v, data in edges: key = tuple(sorted([u, v])) edge_map.setdefault(key, []).append(data['resistance']) for (u, v), resistances in edge_map.items(): if len(resistances) > 1: req = 1 / sum(1 / r for r in resistances) # Remove all parallel edges and add a single equivalent edge graph.remove_edges_from([(u, v) for _ in resistances]) graph.add_edge(u, v, resistance=req) changed = True break return changed def equivalent_resistance(graph, start, end): \"\"\" Iteratively simplifies the circuit graph until only one equivalent resistor remains between the start and end nodes. \"\"\" while graph.number_of_nodes() > 2: series_changed = combine_series_resistors(graph) parallel_changed = combine_parallel_resistors(graph) if not (series_changed or parallel_changed): break # No further reduction possible if graph.has_edge(start, end): return graph[start][end]['resistance'] else: return None # ----- Example Usage ----- # Construct a sample circuit graph graph = nx.Graph() # Example circuit: # Nodes: A, B, C, D with multiple series and parallel connections. graph.add_edge('A', 'B', resistance=5) graph.add_edge('B', 'C', resistance=10) graph.add_edge('C', 'D', resistance=15) graph.add_edge('A', 'D', resistance=6) graph.add_edge('B', 'D', resistance=3) # Compute the equivalent resistance between nodes A and D. eq_res = equivalent_resistance(graph, 'A', 'D') print(\"Equivalent Resistance between A and D:\", eq_res) # ----- Visualization of the Simplified Circuit Graph ----- pos = nx.spring_layout(graph) # Compute a layout for the graph nx.draw(graph, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=500) labels = nx.get_edge_attributes(graph, 'resistance') nx.draw_networkx_edge_labels(graph, pos, edge_labels=labels) plt.title(\"Simplified Circuit Graph with Resistances\") plt.show()","title":"Equivalent Resistance Calculation with Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 1. Simulating Sampling Distributions Selected Population Distributions We'll use the following types: Uniform Distribution (e.g., between 0 and 1) Exponential Distribution (e.g., scale = 1.0) Binomial Distribution (e.g., \\(n = 10\\) , \\(p = 0.5\\) ) Python Code to Generate Populations import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Population sizes pop_size = 100000 # Generate populations uniform_pop = np.random.uniform(0, 1, pop_size) exponential_pop = np.random.exponential(scale=1.0, size=pop_size) binomial_pop = np.random.binomial(n=10, p=0.5, size=pop_size) # Plot each distribution plt.figure(figsize=(15, 4)) # Uniform plt.subplot(1, 3, 1) sns.histplot(uniform_pop, kde=True, bins=50, color='skyblue') plt.title(\"Uniform Distribution\") # Exponential plt.subplot(1, 3, 2) sns.histplot(exponential_pop, kde=True, bins=50, color='orange') plt.title(\"Exponential Distribution\") # Binomial plt.subplot(1, 3, 3) sns.histplot(binomial_pop, kde=True, bins=50, color='green') plt.title(\"Binomial Distribution\") plt.tight_layout() plt.show() 2. Sampling and Visualization Sampling Strategy Choose different sample sizes: 5, 10, 30, 50 Draw many random samples (e.g., 1000 samples per size) Calculate the sample mean for each sample Plot the distribution of sample means Python Code for Sampling and Plotting import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Define population (you can change this to uniform_pop, exponential_pop, etc.) population = np.random.exponential(scale=1.0, size=100000) # Sample sizes to test sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Repetitions per sample size # Set up plot plt.figure(figsize=(15, 8)) for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n) sample_means.append(np.mean(sample)) # Plot histogram of sample means plt.subplot(2, 2, i+1) sns.histplot(sample_means, kde=True, bins=30, color='purple') plt.title(f'Sample Size = {n}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.tight_layout() plt.suptitle(\"Sampling Distributions of the Mean\", y=1.02, fontsize=16) plt.show() 3. Parameter Exploration Key Factors to Investigate Original distribution shape: Symmetric (Uniform) Skewed (Exponential) Discrete (Binomial) Sample size: Small (e.g., 5\u201310) \u2192 slow convergence Larger (e.g., 30\u201350) \u2192 faster convergence Population variance: Affects spread of the sampling distribution High variance \u2192 wider sampling distribution Observations to Highlight Exponential Distribution: Strongly skewed, but sample means become symmetric with larger \\(n\\) . Uniform Distribution: Converges quickly since it\u2019s already bounded and symmetric. Binomial Distribution (with low \\(n\\) ): Discrete jumps are visible, but smooth out with sampling. Higher Variance = Slower Convergence: Sample means spread out more, requiring larger \\(n\\) to approach normality. 4. Practical Applications of the Central Limit Theorem Why CLT Matters The Central Limit Theorem (CLT) is critical in statistics because it allows us to make predictions and decisions based on sample data , even if the population distribution is unknown. Estimating Population Parameters Sample means follow a normal distribution for large enough samples. Enables construction of confidence intervals and hypothesis testing . Used in surveys, experiments, and polling (e.g., predicting election outcomes). Quality Control in Manufacturing CLT helps track mean product quality over time. Sample-based control charts rely on the assumption that the mean of measurements is normally distributed . Essential for detecting shifts or defects in production. Financial Modeling Returns and risks are modeled assuming normally distributed averages . CLT justifies using sample averages to estimate expected returns or volatility. Supports risk analysis and portfolio optimization .","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#selected-population-distributions","text":"We'll use the following types: Uniform Distribution (e.g., between 0 and 1) Exponential Distribution (e.g., scale = 1.0) Binomial Distribution (e.g., \\(n = 10\\) , \\(p = 0.5\\) )","title":"Selected Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-to-generate-populations","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Population sizes pop_size = 100000 # Generate populations uniform_pop = np.random.uniform(0, 1, pop_size) exponential_pop = np.random.exponential(scale=1.0, size=pop_size) binomial_pop = np.random.binomial(n=10, p=0.5, size=pop_size) # Plot each distribution plt.figure(figsize=(15, 4)) # Uniform plt.subplot(1, 3, 1) sns.histplot(uniform_pop, kde=True, bins=50, color='skyblue') plt.title(\"Uniform Distribution\") # Exponential plt.subplot(1, 3, 2) sns.histplot(exponential_pop, kde=True, bins=50, color='orange') plt.title(\"Exponential Distribution\") # Binomial plt.subplot(1, 3, 3) sns.histplot(binomial_pop, kde=True, bins=50, color='green') plt.title(\"Binomial Distribution\") plt.tight_layout() plt.show()","title":"Python Code to Generate Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-strategy","text":"Choose different sample sizes: 5, 10, 30, 50 Draw many random samples (e.g., 1000 samples per size) Calculate the sample mean for each sample Plot the distribution of sample means","title":"Sampling Strategy"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-for-sampling-and-plotting","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Define population (you can change this to uniform_pop, exponential_pop, etc.) population = np.random.exponential(scale=1.0, size=100000) # Sample sizes to test sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Repetitions per sample size # Set up plot plt.figure(figsize=(15, 8)) for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n) sample_means.append(np.mean(sample)) # Plot histogram of sample means plt.subplot(2, 2, i+1) sns.histplot(sample_means, kde=True, bins=30, color='purple') plt.title(f'Sample Size = {n}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') plt.tight_layout() plt.suptitle(\"Sampling Distributions of the Mean\", y=1.02, fontsize=16) plt.show()","title":"Python Code for Sampling and Plotting"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-factors-to-investigate","text":"Original distribution shape: Symmetric (Uniform) Skewed (Exponential) Discrete (Binomial) Sample size: Small (e.g., 5\u201310) \u2192 slow convergence Larger (e.g., 30\u201350) \u2192 faster convergence Population variance: Affects spread of the sampling distribution High variance \u2192 wider sampling distribution","title":"Key Factors to Investigate"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations-to-highlight","text":"Exponential Distribution: Strongly skewed, but sample means become symmetric with larger \\(n\\) . Uniform Distribution: Converges quickly since it\u2019s already bounded and symmetric. Binomial Distribution (with low \\(n\\) ): Discrete jumps are visible, but smooth out with sampling. Higher Variance = Slower Convergence: Sample means spread out more, requiring larger \\(n\\) to approach normality.","title":"Observations to Highlight"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications-of-the-central-limit-theorem","text":"","title":"4. Practical Applications of the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#why-clt-matters","text":"The Central Limit Theorem (CLT) is critical in statistics because it allows us to make predictions and decisions based on sample data , even if the population distribution is unknown.","title":"Why CLT Matters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#estimating-population-parameters","text":"Sample means follow a normal distribution for large enough samples. Enables construction of confidence intervals and hypothesis testing . Used in surveys, experiments, and polling (e.g., predicting election outcomes).","title":"Estimating Population Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#quality-control-in-manufacturing","text":"CLT helps track mean product quality over time. Sample-based control charts rely on the assumption that the mean of measurements is normally distributed . Essential for detecting shifts or defects in production.","title":"Quality Control in Manufacturing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#financial-modeling","text":"Returns and risks are modeled assuming normally distributed averages . CLT justifies using sample averages to estimate expected returns or volatility. Supports risk analysis and portfolio optimization .","title":"Financial Modeling"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo \u2013 Circle Method 1. Theoretical Foundation We estimate \u03c0 by simulating points in a square and checking how many fall inside an inscribed circle. For a unit circle centered at the origin, any point \\((x, y)\\) lies inside the circle if: \\[ x^2 + y^2 \\leq 1 \\] The area of the full square is \\(4\\) (from \\([-1, 1] \\times [-1, 1]\\) ). The area of the unit circle is \\(\u03c0\\) . The ratio of points inside the circle to the total points approximates the ratio of their areas: \\[ \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\approx \\frac{\u03c0}{4} \\] Rearranging: \\[ \u03c0 \\approx 4 \\cdot \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\] 2. Simulation \u2013 Estimating \u03c0 import numpy as np def estimate_pi(num_points=10000): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points return pi_estimate, x, y, inside_circle # Example usage pi, x_vals, y_vals, mask = estimate_pi(10000) print(f\"Estimated \u03c0 \u2248 {pi}\") Estimated \u03c0 \u2248 3.1548 3. Visualization of Points import matplotlib.pyplot as plt def plot_points(x, y, inside_circle): plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], s=1, color='green', label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], s=1, color='red', label='Outside Circle') plt.gca().set_aspect('equal') plt.title(\"Monte Carlo \u03c0 Estimation\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.legend() plt.grid(True) plt.show() plot_points(x_vals, y_vals, mask) 4. Accuracy and Convergence Observing Convergencee import matplotlib.pyplot as plt sample_sizes = [10, 100, 1000, 5000, 10000, 50000, 100000] estimates = [] for n in sample_sizes: pi_est, *_ = estimate_pi(n) estimates.append(pi_est) plt.plot(sample_sizes, estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label='True \u03c0') plt.title(\"Convergence of \u03c0 Estimate\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.xscale('log') plt.show() Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Foundation Problem Description Buffon\u2019s Needle is a classic probability problem: Drop a needle of length \\(L\\) onto a plane with equally spaced parallel lines a distance \\(d\\) apart. The probability \\(P\\) of the needle crossing a line is related to \\(\u03c0\\) : \\[ P = \\frac{2L}{d\u03c0} \\] Deriving \u03c0 Rearranged to estimate \u03c0: \\[ \u03c0 \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: - \\(L\\) = needle length - \\(d\\) = distance between lines - \\(N\\) = total number of throws - \\(C\\) = number of times the needle crosses a line Note: Valid only when \\(L \\leq d\\) 2. Simulation import numpy as np def buffon_needle(num_throws=10000, L=1.0, d=1.5): assert L <= d, \"Needle length must be less than or equal to spacing between lines.\" # Random needle midpoints and angles y_center = np.random.uniform(0, d / 2, num_throws) theta = np.random.uniform(0, np.pi / 2, num_throws) # Check if needle crosses a line crosses = y_center <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) # Estimate \u03c0 if num_crosses == 0: return None # Avoid division by zero pi_est = (2 * L * num_throws) / (d * num_crosses) return pi_est, y_center, theta, crosses only runs the calculation \u2014 it doesn't produce a plot by itself. 3. Visualization import matplotlib.pyplot as plt def plot_needles(y_center, theta, crosses, L=1.0, d=1.5, num_shown=200): x_center = np.zeros_like(y_center) dx = (L / 2) * np.cos(theta) dy = (L / 2) * np.sin(theta) plt.figure(figsize=(8, 6)) for i in range(min(num_shown, len(y_center))): x0 = x_center[i] - dx[i] x1 = x_center[i] + dx[i] y0 = y_center[i] - dy[i] y1 = y_center[i] + dy[i] color = 'red' if crosses[i] else 'blue' plt.plot([x0, x1], [y0, y1], color=color) # Draw parallel lines for y in np.arange(0, 10*d, d): plt.axhline(y, color='black', linewidth=0.5, linestyle='--') plt.title(\"Buffon\u2019s Needle Simulation (Red = Crossing)\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis('equal') plt.grid(True) plt.show() It doesnt produce a plot because it needs input from the simulation first. The following code below builds on the Buffon\u2019s Needle simulation and includes a visual representation of the needle drops: Red needles indicate those that crossed a line. Blue needles indicate those that did not cross . Dashed black lines represent the parallel floor lines . This visualization helps us understand how the estimate of \u03c0 is formed geometrically. It uses the output from the simulation to produce an intuitive and engaging plot of the experiment. import numpy as np import matplotlib.pyplot as plt # --- Buffon\u2019s Needle Simulation --- def buffon_needle(num_throws=1000, L=1.0, d=1.5): assert L <= d, \"Needle length must be less than or equal to spacing between lines.\" # Generate random midpoints and angles y_center = np.random.uniform(0, d / 2, num_throws) theta = np.random.uniform(0, np.pi / 2, num_throws) # Check if needle crosses a line crosses = y_center <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) if num_crosses == 0: return None, y_center, theta, crosses # Avoid division by zero # Estimate \u03c0 pi_estimate = (2 * L * num_throws) / (d * num_crosses) return pi_estimate, y_center, theta, crosses # --- Needle Plotting Function --- def plot_needles(y_center, theta, crosses, L=1.0, d=1.5, num_shown=300): x_center = np.zeros_like(y_center) dx = (L / 2) * np.cos(theta) dy = (L / 2) * np.sin(theta) plt.figure(figsize=(8, 6)) for i in range(min(num_shown, len(y_center))): x0 = x_center[i] - dx[i] x1 = x_center[i] + dx[i] y0 = y_center[i] - dy[i] y1 = y_center[i] + dy[i] color = 'red' if crosses[i] else 'blue' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) # Draw parallel lines for y in np.arange(0, 10 * d, d): plt.axhline(y, color='black', linewidth=0.5, linestyle='--') plt.title(\"Buffon\u2019s Needle Simulation (Red = Crossed Line)\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis(\"equal\") plt.grid(True) plt.show() # --- Run Simulation and Plot --- pi_val, y_vals, theta_vals, cross_mask = buffon_needle(num_throws=1000) print(f\"Estimated \u03c0 \u2248 {pi_val:.6f}\") plot_needles(y_vals, theta_vals, cross_mask) 4. Analysis of Accuracy and Convergence sample_sizes = [100, 500, 1000, 5000, 10000, 50000] pi_estimates = [] for n in sample_sizes: pi_val, *_ = buffon_needle(num_throws=n) pi_estimates.append(pi_val) plt.plot(sample_sizes, pi_estimates, marker='o') plt.axhline(np.pi, color='green', linestyle='--', label='True \u03c0') plt.title(\"Buffon\u2019s Needle: Convergence of \u03c0 Estimate\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.xscale(\"log\") plt.show()","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-circle-method","text":"","title":"Estimating \u03c0 Using Monte Carlo \u2013 Circle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"We estimate \u03c0 by simulating points in a square and checking how many fall inside an inscribed circle. For a unit circle centered at the origin, any point \\((x, y)\\) lies inside the circle if: \\[ x^2 + y^2 \\leq 1 \\] The area of the full square is \\(4\\) (from \\([-1, 1] \\times [-1, 1]\\) ). The area of the unit circle is \\(\u03c0\\) . The ratio of points inside the circle to the total points approximates the ratio of their areas: \\[ \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\approx \\frac{\u03c0}{4} \\] Rearranging: \\[ \u03c0 \\approx 4 \\cdot \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-estimating","text":"import numpy as np def estimate_pi(num_points=10000): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points return pi_estimate, x, y, inside_circle # Example usage pi, x_vals, y_vals, mask = estimate_pi(10000) print(f\"Estimated \u03c0 \u2248 {pi}\") Estimated \u03c0 \u2248 3.1548","title":"2. Simulation \u2013 Estimating \u03c0"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization-of-points","text":"import matplotlib.pyplot as plt def plot_points(x, y, inside_circle): plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], s=1, color='green', label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], s=1, color='red', label='Outside Circle') plt.gca().set_aspect('equal') plt.title(\"Monte Carlo \u03c0 Estimation\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.legend() plt.grid(True) plt.show() plot_points(x_vals, y_vals, mask)","title":"3. Visualization of Points"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-accuracy-and-convergence","text":"","title":"4. Accuracy and Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#observing-convergencee","text":"import matplotlib.pyplot as plt sample_sizes = [10, 100, 1000, 5000, 10000, 50000, 100000] estimates = [] for n in sample_sizes: pi_est, *_ = estimate_pi(n) estimates.append(pi_est) plt.plot(sample_sizes, estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label='True \u03c0') plt.title(\"Convergence of \u03c0 Estimate\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.xscale('log') plt.show()","title":"Observing Convergencee"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-buffons-needle","text":"","title":"Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-description","text":"Buffon\u2019s Needle is a classic probability problem: Drop a needle of length \\(L\\) onto a plane with equally spaced parallel lines a distance \\(d\\) apart. The probability \\(P\\) of the needle crossing a line is related to \\(\u03c0\\) : \\[ P = \\frac{2L}{d\u03c0} \\]","title":"Problem Description"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deriving","text":"Rearranged to estimate \u03c0: \\[ \u03c0 \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: - \\(L\\) = needle length - \\(d\\) = distance between lines - \\(N\\) = total number of throws - \\(C\\) = number of times the needle crosses a line Note: Valid only when \\(L \\leq d\\)","title":"Deriving \u03c0"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"import numpy as np def buffon_needle(num_throws=10000, L=1.0, d=1.5): assert L <= d, \"Needle length must be less than or equal to spacing between lines.\" # Random needle midpoints and angles y_center = np.random.uniform(0, d / 2, num_throws) theta = np.random.uniform(0, np.pi / 2, num_throws) # Check if needle crosses a line crosses = y_center <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) # Estimate \u03c0 if num_crosses == 0: return None # Avoid division by zero pi_est = (2 * L * num_throws) / (d * num_crosses) return pi_est, y_center, theta, crosses only runs the calculation \u2014 it doesn't produce a plot by itself.","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"import matplotlib.pyplot as plt def plot_needles(y_center, theta, crosses, L=1.0, d=1.5, num_shown=200): x_center = np.zeros_like(y_center) dx = (L / 2) * np.cos(theta) dy = (L / 2) * np.sin(theta) plt.figure(figsize=(8, 6)) for i in range(min(num_shown, len(y_center))): x0 = x_center[i] - dx[i] x1 = x_center[i] + dx[i] y0 = y_center[i] - dy[i] y1 = y_center[i] + dy[i] color = 'red' if crosses[i] else 'blue' plt.plot([x0, x1], [y0, y1], color=color) # Draw parallel lines for y in np.arange(0, 10*d, d): plt.axhline(y, color='black', linewidth=0.5, linestyle='--') plt.title(\"Buffon\u2019s Needle Simulation (Red = Crossing)\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis('equal') plt.grid(True) plt.show() It doesnt produce a plot because it needs input from the simulation first. The following code below builds on the Buffon\u2019s Needle simulation and includes a visual representation of the needle drops: Red needles indicate those that crossed a line. Blue needles indicate those that did not cross . Dashed black lines represent the parallel floor lines . This visualization helps us understand how the estimate of \u03c0 is formed geometrically. It uses the output from the simulation to produce an intuitive and engaging plot of the experiment. import numpy as np import matplotlib.pyplot as plt # --- Buffon\u2019s Needle Simulation --- def buffon_needle(num_throws=1000, L=1.0, d=1.5): assert L <= d, \"Needle length must be less than or equal to spacing between lines.\" # Generate random midpoints and angles y_center = np.random.uniform(0, d / 2, num_throws) theta = np.random.uniform(0, np.pi / 2, num_throws) # Check if needle crosses a line crosses = y_center <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) if num_crosses == 0: return None, y_center, theta, crosses # Avoid division by zero # Estimate \u03c0 pi_estimate = (2 * L * num_throws) / (d * num_crosses) return pi_estimate, y_center, theta, crosses # --- Needle Plotting Function --- def plot_needles(y_center, theta, crosses, L=1.0, d=1.5, num_shown=300): x_center = np.zeros_like(y_center) dx = (L / 2) * np.cos(theta) dy = (L / 2) * np.sin(theta) plt.figure(figsize=(8, 6)) for i in range(min(num_shown, len(y_center))): x0 = x_center[i] - dx[i] x1 = x_center[i] + dx[i] y0 = y_center[i] - dy[i] y1 = y_center[i] + dy[i] color = 'red' if crosses[i] else 'blue' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) # Draw parallel lines for y in np.arange(0, 10 * d, d): plt.axhline(y, color='black', linewidth=0.5, linestyle='--') plt.title(\"Buffon\u2019s Needle Simulation (Red = Crossed Line)\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis(\"equal\") plt.grid(True) plt.show() # --- Run Simulation and Plot --- pi_val, y_vals, theta_vals, cross_mask = buffon_needle(num_throws=1000) print(f\"Estimated \u03c0 \u2248 {pi_val:.6f}\") plot_needles(y_vals, theta_vals, cross_mask)","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis-of-accuracy-and-convergence","text":"sample_sizes = [100, 500, 1000, 5000, 10000, 50000] pi_estimates = [] for n in sample_sizes: pi_val, *_ = buffon_needle(num_throws=n) pi_estimates.append(pi_val) plt.plot(sample_sizes, pi_estimates, marker='o') plt.axhline(np.pi, color='green', linestyle='--', label='True \u03c0') plt.title(\"Buffon\u2019s Needle: Convergence of \u03c0 Estimate\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.xscale(\"log\") plt.show()","title":"4. Analysis of Accuracy and Convergence"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration Using a Pendulum 1. Theoretical Foundation A simple pendulum (of small amplitude) has a period given by: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Where: - \\(T\\) is the period (time for one complete oscillation), - \\(L\\) is the length of the pendulum, - \\(g\\) is the acceleration due to gravity. Rearranging the formula to solve for \\(g\\) , we obtain: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] This relation provides a straightforward method to measure \\(g\\) by measuring \\(L\\) and \\(T\\) . 2. Simulation The following Python code simulates the oscillations of a simple pendulum. It generates synthetic period data (with some random noise to mimic measurement errors) and then uses these periods to estimate \\(g\\) . import numpy as np import matplotlib.pyplot as plt # Pendulum parameters L = 1.0 # Length in meters g_true = 9.81 # True gravitational acceleration (m/s\u00b2) T_true = 2 * np.pi * np.sqrt(L / g_true) # Theoretical period # Generate simulated period data with noise (simulate multiple trials) num_trials = 100 # Adding normal noise with 0.02 sec standard deviation to mimic experimental error measured_periods = T_true + np.random.normal(0, 0.02, num_trials) # Estimate g from each measured period using: g = 4\u03c0\u00b2L/T\u00b2 g_estimates = 4 * np.pi**2 * L / measured_periods**2 # Compute average estimated g and standard deviation g_mean = np.mean(g_estimates) g_std = np.std(g_estimates) print(f\"Estimated g: {g_mean:.2f} m/s\u00b2 \u00b1 {g_std:.2f} m/s\u00b2\") Estimated g: 9.85 m/s\u00b2 \u00b1 0.21 m/s\u00b2 3. Simulation A. Histogram of Measured Periods The histogram below shows the distribution of the measured periods: plt.figure(figsize=(8, 4)) plt.hist(measured_periods, bins=15, color='skyblue', edgecolor='black') plt.title(\"Histogram of Measured Pendulum Periods\") plt.xlabel(\"Period (s)\") plt.ylabel(\"Frequency\") plt.show() B. Histogram of Estimated \\(g\\) Values The following plot visualizes how the estimated \\(g\\) values are distributed: plt.figure(figsize=(8, 4)) plt.hist(g_estimates, bins=15, color='salmon', edgecolor='black') plt.title(\"Histogram of Estimated g\") plt.xlabel(\"g (m/s\u00b2)\") plt.ylabel(\"Frequency\") plt.show() C. Period vs. Length Plot To further verify the theoretical relationship, we can plot the period as a function of pendulum length: # Simulate for different pendulum lengths lengths = np.linspace(0.5, 2.0, 20) # Lengths from 0.5 m to 2.0 m T_values = 2 * np.pi * np.sqrt(lengths / g_true) plt.figure(figsize=(8, 6)) plt.plot(lengths, T_values, 'o-', label='Theoretical T') plt.title(\"Pendulum Period vs. Length\") plt.xlabel(\"Length (m)\") plt.ylabel(\"Period (s)\") plt.legend() plt.grid(True) plt.show() 4. Analysis and Discussion Convergence: As the number of trials increases, the average estimated \\(g\\) converges to the true value (9.81 m/s\u00b2). The simulation demonstrates that even with measurement noise, averaging over many trials reduces the error. Impact of Measurement Noise: Small random errors in \\(T\\) can lead to variability in the estimated \\(g\\) due to the quadratic relationship in the formula. However, increasing the sample size reduces the uncertainty. Assumptions and Limitations: Small Angle Approximation: The formula \\(T = 2\\pi \\sqrt{\\frac{L}{g}}\\) assumes small oscillation angles. For larger angles, a correction is needed. Neglected Factors: Air resistance and friction at the pivot are ignored, which in practice might affect the period slightly. Practical Applications: Measuring \\(g\\) accurately is crucial in experimental physics and engineering\u2014for calibrating instruments and understanding gravitational effects on structures. This pendulum method serves as an accessible, low-cost experiment for these purposes.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-using-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration Using a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-theoretical-foundation","text":"A simple pendulum (of small amplitude) has a period given by: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Where: - \\(T\\) is the period (time for one complete oscillation), - \\(L\\) is the length of the pendulum, - \\(g\\) is the acceleration due to gravity. Rearranging the formula to solve for \\(g\\) , we obtain: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] This relation provides a straightforward method to measure \\(g\\) by measuring \\(L\\) and \\(T\\) .","title":"1. Theoretical Foundation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-simulation","text":"The following Python code simulates the oscillations of a simple pendulum. It generates synthetic period data (with some random noise to mimic measurement errors) and then uses these periods to estimate \\(g\\) . import numpy as np import matplotlib.pyplot as plt # Pendulum parameters L = 1.0 # Length in meters g_true = 9.81 # True gravitational acceleration (m/s\u00b2) T_true = 2 * np.pi * np.sqrt(L / g_true) # Theoretical period # Generate simulated period data with noise (simulate multiple trials) num_trials = 100 # Adding normal noise with 0.02 sec standard deviation to mimic experimental error measured_periods = T_true + np.random.normal(0, 0.02, num_trials) # Estimate g from each measured period using: g = 4\u03c0\u00b2L/T\u00b2 g_estimates = 4 * np.pi**2 * L / measured_periods**2 # Compute average estimated g and standard deviation g_mean = np.mean(g_estimates) g_std = np.std(g_estimates) print(f\"Estimated g: {g_mean:.2f} m/s\u00b2 \u00b1 {g_std:.2f} m/s\u00b2\") Estimated g: 9.85 m/s\u00b2 \u00b1 0.21 m/s\u00b2","title":"2. Simulation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-simulation","text":"","title":"3. Simulation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#a-histogram-of-measured-periods","text":"The histogram below shows the distribution of the measured periods: plt.figure(figsize=(8, 4)) plt.hist(measured_periods, bins=15, color='skyblue', edgecolor='black') plt.title(\"Histogram of Measured Pendulum Periods\") plt.xlabel(\"Period (s)\") plt.ylabel(\"Frequency\") plt.show()","title":"A. Histogram of Measured Periods"},{"location":"1%20Physics/7%20Measurements/Problem_1/#b-histogram-of-estimated-g-values","text":"The following plot visualizes how the estimated \\(g\\) values are distributed: plt.figure(figsize=(8, 4)) plt.hist(g_estimates, bins=15, color='salmon', edgecolor='black') plt.title(\"Histogram of Estimated g\") plt.xlabel(\"g (m/s\u00b2)\") plt.ylabel(\"Frequency\") plt.show()","title":"B. Histogram of Estimated \\(g\\) Values"},{"location":"1%20Physics/7%20Measurements/Problem_1/#c-period-vs-length-plot","text":"To further verify the theoretical relationship, we can plot the period as a function of pendulum length: # Simulate for different pendulum lengths lengths = np.linspace(0.5, 2.0, 20) # Lengths from 0.5 m to 2.0 m T_values = 2 * np.pi * np.sqrt(lengths / g_true) plt.figure(figsize=(8, 6)) plt.plot(lengths, T_values, 'o-', label='Theoretical T') plt.title(\"Pendulum Period vs. Length\") plt.xlabel(\"Length (m)\") plt.ylabel(\"Period (s)\") plt.legend() plt.grid(True) plt.show()","title":"C. Period vs. Length Plot"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-analysis-and-discussion","text":"Convergence: As the number of trials increases, the average estimated \\(g\\) converges to the true value (9.81 m/s\u00b2). The simulation demonstrates that even with measurement noise, averaging over many trials reduces the error. Impact of Measurement Noise: Small random errors in \\(T\\) can lead to variability in the estimated \\(g\\) due to the quadratic relationship in the formula. However, increasing the sample size reduces the uncertainty. Assumptions and Limitations: Small Angle Approximation: The formula \\(T = 2\\pi \\sqrt{\\frac{L}{g}}\\) assumes small oscillation angles. For larger angles, a correction is needed. Neglected Factors: Air resistance and friction at the pivot are ignored, which in practice might affect the period slightly. Practical Applications: Measuring \\(g\\) accurately is crucial in experimental physics and engineering\u2014for calibrating instruments and understanding gravitational effects on structures. This pendulum method serves as an accessible, low-cost experiment for these purposes.","title":"4. Analysis and Discussion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}